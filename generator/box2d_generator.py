import ctypes, re, sys
import box2d_parser

PREFIX = """# Ruby-Box2D : Yet another Box2D wrapper for Ruby
#
# * https://github.com/vaiorabbit/box2d-bindings
#
# [NOTICE] Autogenerated. Do not edit.

require 'ffi'
"""

POSTFIX = """
end
"""

####################################################################################################

def sanitize_enum(ctx):
    pass

def sanitize_macro(ctx):
    # 0x____u -> 0x____
    pattern = re.compile(r'(0x[0-9a-fA-F]+)u')
    for macro_name, macro_value in ctx.decl_macros.items():
        if len(macro_value) != 1:
            continue
        m = re.search(pattern, macro_value[0])
        if m:
            ctx.decl_macros[macro_name][0] = m.group(1)

    # refer mapping
    for macro_name, macro_value in ctx.decl_macros.items():
        define_mapping = box2d_parser.get_define_mapping(macro_name)
        if define_mapping:
            ctx.decl_macros[macro_name] = define_mapping
        else:
            ctx.decl_macros[macro_name] = None

    # contatinate (SDL_INIT_EVERYTHING, etc.)
    for macro_name, macro_value in ctx.decl_macros.items():
        if macro_value == None or len(macro_value) <= 1:
            continue
        ctx.decl_macros[macro_name] = [''.join(macro_value)]

def sanitize_struct(ctx):
    for struct_name, struct_info in ctx.decl_structs.items():
        if struct_info == None:
            continue
        underlying_ctypes_type = "FFI::Union" if str(struct_info.kind) == "CursorKind.UNION_DECL" else "FFI::Struct"
        struct_info.kind = underlying_ctypes_type
        for field in struct_info.fields:
            if str(field.type_kind) == "TypeKind.FUNCTIONNOPROTO": # for BL_DEFINE_OBJECT_DCAST(BLGlyphBuffer) (glyphbuffer.h)
                field.type_kind = None
            else:
                field.type_kind = box2d_parser.get_cindex_ctypes_mapping(str(field.type_kind), field.type_api_name)

def sanitize_typedef(ctx):
    # refer mapping
    for typedef_name, typedef_info in ctx.decl_typedefs.items():
        if typedef_info == None:
            continue
        if typedef_info.func_proto != None:
            for arg in typedef_info.func_proto.args:
                arg.type_kind = box2d_parser.get_cindex_ctypes_mapping(str(arg.type_kind), arg.type_name)
            typedef_info.func_proto.retval.type_kind = box2d_parser.get_cindex_ctypes_mapping(str(typedef_info.func_proto.retval.type_kind), typedef_info.func_proto.retval.type_original_name)
        else:
            if str(typedef_info.type_kind) == "TypeKind.RECORD":
                typedef_info.type_kind = None
            else:
                typedef_info.type_kind = box2d_parser.get_cindex_ctypes_mapping(str(typedef_info.type_kind), typedef_info.original_name)

def sanitize_function(ctx):
    for func_name, func_info in ctx.decl_functions.items():
        if func_info == None:
            continue
        for arg in func_info.args:
            if box2d_parser.is_box2d_callback_type(arg.type_kind, arg.type_name):
                arg.type_kind = ":" + arg.type_name
            else:
                arg.type_kind = box2d_parser.get_cindex_ctypes_mapping(str(arg.type_kind), arg.type_name)
        func_info.retval.type_kind = box2d_parser.get_cindex_ctypes_mapping(str(func_info.retval.type_kind), func_info.retval.type_original_name)

def sanitize(ctx):
    sanitize_enum(ctx)
    sanitize_macro(ctx)
    sanitize_struct(ctx)
    sanitize_typedef(ctx)
    sanitize_function(ctx)

####################################################################################################

def generate_macrodefine(ctx, indent = ""):
    for macro_name, macro_value in ctx.decl_macros.items():
        if macro_value != None:
            macro_api_name = ""
            match_obj = re.match(r"^SDL_(.+)", macro_name)
            if match_obj:
                # Remove prefix 'SDL_' from name
                macro_api_name = match_obj.group(1)
            else:
                macro_api_name = macro_name
            print(indent + "%s = %s" % (macro_api_name, macro_value[0]), file = sys.stdout)

def generate_enum(ctx, indent = ""):
    for enum_name, enum_value in ctx.decl_enums.items():
        if enum_value != None:
            for enum in enum_value:
                enum_api_name = ""
                match_obj = re.match(r"^SDL_(.+)", enum[0])
                if match_obj:
                    # Remove prefix 'SDL_' from name
                    enum_api_name = match_obj.group(1)
                else:
                    enum_api_name = enum[0]
                print(indent + "%s = %s" % (enum_api_name, enum[1]), file = sys.stdout)

def generate_typedef(ctx, indent = "", typedef_prefix="", typedef_postfix=""):
    if typedef_prefix != "":
        print(typedef_prefix, file = sys.stdout)
    for typedef_name, typedef_info in ctx.decl_typedefs.items():
        if typedef_info == None:
            continue
        if typedef_info.type_kind == None:
            continue
        if typedef_info.func_proto != None:
            typedef_line = "callback :%s, ["  % typedef_name
            for i, arg in enumerate(typedef_info.func_proto.args):
                typedef_line += "%s%s" % ("" if i == 0 else ", ",  arg.type_kind)
            typedef_line += "], %s" % typedef_info.func_proto.retval.type_kind
        else:
            typedef_line = "typedef %s, :%s" % (typedef_info.type_kind, typedef_name)
        print(indent + typedef_line, file = sys.stdout)
    if typedef_postfix != "":
        print(typedef_postfix, file = sys.stdout)

def generate_structunion(ctx, indent = "", struct_prefix="", struct_postfix=""):
    if struct_prefix != "":
        print(struct_prefix, file = sys.stdout)
    for struct_name, struct_info in ctx.decl_structs.items():
        if struct_info == None:
            continue

        # Print body of struct from here
        print(indent + "class %s < %s" % (struct_info.api_name, struct_info.kind), file = sys.stdout)
        print(indent + "  layout(", file = sys.stdout)
        for field in struct_info.fields:
            if field.type_kind == None:
                continue
            if field.element_count <= 1:
                print(indent + "    :%s, %s," % (field.element_name, field.type_kind), file = sys.stdout)
            else:
                print(indent + "    :%s, [%s, %s]," % (field.element_name, field.type_kind, field.element_count), file = sys.stdout)
        print(indent + "  )", file = sys.stdout)

        # Print accessors
        for field in struct_info.fields:
            print(indent + "  def %s = self[:%s]" % (field.element_name, field.element_name), file = sys.stdout)
            print(indent + "  def %s=(v) self[:%s] = v end" % (field.element_name, field.element_name), file = sys.stdout)

        func_name_prefix = ('bl' + struct_name.removeprefix('b2')) #.removesuffix('Core')

        # Print instance methods
        creator_methods_generated = False
        for func_name, func_info in ctx.decl_functions.items():
            if func_name.startswith(func_name_prefix):
                method_name = func_name.removeprefix(func_name_prefix)
                args_name_list = []
                if len(func_info.args) > 0:
                    args_name_list = list(map((lambda t: str(t.original_name)), func_info.args))
                args_with_self = ', '.join(args_name_list)
                args_without_self = ', '.join(args_name_list[1:])
                print(indent + "  def %s(%s) = %s(%s)" % (method_name[0].lower() + method_name[1:], args_without_self, func_name, args_with_self), file = sys.stdout)
                if method_name == 'Init':
                    # Print instance creator methods
                    print(indent + "  def self.create()", file = sys.stdout)
                    print(indent + "    instance = %s.new" % (struct_name), file = sys.stdout)
                    print(indent + "    %s(instance)" % (func_name), file = sys.stdout)
                    print(indent + "    instance", file = sys.stdout)
                    print(indent + "  end", file = sys.stdout)
                    creator_methods_generated = True
                if method_name == 'InitAs':
                    # Print instance creator methods
                    print(indent + "  def self.create_as(%s)" % (args_without_self) , file = sys.stdout)
                    print(indent + "    instance = %s.new" % (struct_name), file = sys.stdout)
                    print(indent + "    %s(instance, %s)" % (func_name, args_without_self), file = sys.stdout)
                    print(indent + "    instance", file = sys.stdout)
                    print(indent + "  end", file = sys.stdout)
                    creator_methods_generated = True
        if not creator_methods_generated:
            # Print instance creator methods
            args_name_list = list(map((lambda f: '_' + str(f.element_name) + '_'), struct_info.fields))
            print(indent + "  def self.create_as(%s)" % (', '.join(args_name_list)) , file = sys.stdout)
            print(indent + "    instance = %s.new" % (struct_name), file = sys.stdout)
            for field in struct_info.fields:
                print(indent + "    instance[:%s] = _%s_" % (field.element_name, field.element_name) , file = sys.stdout)
            print(indent + "    instance", file = sys.stdout)
            print(indent + "  end", file = sys.stdout)

        print(indent + "end\n", file = sys.stdout)
    if struct_postfix != "":
        print(struct_postfix, file = sys.stdout)

def generate_function(ctx, indent = "", setup_method_name = ""):
    print(indent + "def self.setup_%s_symbols(output_error = false)" % setup_method_name , file = sys.stdout)
    indent = "  "
    print(indent + "  symbols = [", file = sys.stdout)
    for func_name, func_info in ctx.decl_functions.items():
        if func_info == None:
            continue
        print(indent + "    :%s," % func_info.original_name, file = sys.stdout)
    print(indent + "  ]", file = sys.stdout)

    print(indent + "  apis = {", file = sys.stdout)
    for func_name, func_info in ctx.decl_functions.items():
        if func_info == None:
            continue
        print(indent + "    :%s => :%s," % (func_info.original_name, func_info.api_name), file = sys.stdout)
    print(indent + "  }", file = sys.stdout)

    print(indent + "  args = {", file = sys.stdout)
    for func_name, func_info in ctx.decl_functions.items():
        if func_info == None:
            continue
        print(indent + "    :%s => [" % func_info.original_name, file = sys.stdout, end='')
        if len(func_info.args) > 0:
            # Get Ruby FFI arguments
            args_ctype_list = list(map((lambda t: str(t.type_kind)), func_info.args))

            # Remove leading 'SDL_' string and add ".by_value" to struct arguments (e.g.: Color -> Color.by_value)
            arg_is_record = lambda arg: box2d_parser.query_box2d_cindex_mapping_entry_exists(arg) and box2d_parser.get_box2d_cindex_mapping_value(arg) == "TypeKind.RECORD"
            args_ctype_list = list(map((lambda arg: re.sub('^b2', '', arg) + ".by_value" if arg_is_record(arg) else arg), args_ctype_list))

            print(', '.join(args_ctype_list), file = sys.stdout, end='')
        print("],", file = sys.stdout)
    print(indent + "  }", file = sys.stdout)

    print(indent + "  retvals = {", file = sys.stdout)
    for func_name, func_info in ctx.decl_functions.items():
        if func_info == None:
            continue
        retval_str = str(func_info.retval.type_kind)
        if re.match(r"^SDL_", retval_str): # For functions that return SDL structs by value
            retval_str = func_info.retval.type_api_name + ".by_value"
        print(indent + "    :%s => %s," % (func_info.original_name, retval_str), file = sys.stdout)
    print(indent + "  }", file = sys.stdout)

    print(indent +
      """  symbols.each do |sym|
      begin
        attach_function apis[sym], sym, args[sym], retvals[sym]
      rescue FFI::NotFoundError => error
        $stderr.puts("[Warning] Failed to import #{s}.") if output_error
      end""".format(s="{sym} (#{error})"))
    print(indent + "  end", file = sys.stdout)

    indent = "  "
    print(indent + "end", file = sys.stdout)


def generate(ctx, prefix = PREFIX, postfix = POSTFIX, *, setup_method_name = "", typedef_prefix="", typedef_postfix="", struct_prefix="", struct_postfix=""):

    print(prefix, file = sys.stdout)

    print("module Box2D")

    indent = "  "

    print(indent + "extend FFI::Library")

    # macro
    print(indent + "# Define/Macro\n", file = sys.stdout)
    generate_macrodefine(ctx, indent)
    print("", file = sys.stdout)

    # enum
    print(indent + "# Enum\n", file = sys.stdout)
    generate_enum(ctx, indent)
    print("", file = sys.stdout)

    # typedef
    print(indent + "# Typedef\n", file = sys.stdout)
    generate_typedef(ctx, indent, typedef_prefix, typedef_postfix)
    print("", file = sys.stdout)

    # struct/union
    print(indent + "# Struct\n", file = sys.stdout)
    generate_structunion(ctx, indent, struct_prefix, struct_postfix)
    print("", file = sys.stdout)

    # function
    print(indent + "# Function\n", file = sys.stdout)
    generate_function(ctx, indent, setup_method_name)
    print(postfix, file = sys.stdout)

if __name__ == "__main__":
    pass
