# Ruby-Box2D : Yet another Box2D wrapper for Ruby
#
# * https://github.com/vaiorabbit/box2d-bindings
#
# [NOTICE] Autogenerated. Do not edit.

require 'ffi'

module Box2D
  extend FFI::Library
  # Define/Macro

  DEFAULT_CATEGORY_BITS = 0x0001

  # Enum

  BodyType_staticBody = 0
  BodyType_kinematicBody = 1
  BodyType_dynamicBody = 2
  BodyType_bodyTypeCount = 3
  ShapeType_circleShape = 0
  ShapeType_capsuleShape = 1
  ShapeType_segmentShape = 2
  ShapeType_polygonShape = 3
  ShapeType_chainSegmentShape = 4
  ShapeType_shapeTypeCount = 5
  JointType_distanceJoint = 0
  JointType_motorJoint = 1
  JointType_mouseJoint = 2
  JointType_nullJoint = 3
  JointType_prismaticJoint = 4
  JointType_revoluteJoint = 5
  JointType_weldJoint = 6
  JointType_wheelJoint = 7
  HexColor_colorAliceBlue = 15792383
  HexColor_colorAntiqueWhite = 16444375
  HexColor_colorAqua = 65535
  HexColor_colorAquamarine = 8388564
  HexColor_colorAzure = 15794175
  HexColor_colorBeige = 16119260
  HexColor_colorBisque = 16770244
  HexColor_colorBlack = 0
  HexColor_colorBlanchedAlmond = 16772045
  HexColor_colorBlue = 255
  HexColor_colorBlueViolet = 9055202
  HexColor_colorBrown = 10824234
  HexColor_colorBurlywood = 14596231
  HexColor_colorCadetBlue = 6266528
  HexColor_colorChartreuse = 8388352
  HexColor_colorChocolate = 13789470
  HexColor_colorCoral = 16744272
  HexColor_colorCornflowerBlue = 6591981
  HexColor_colorCornsilk = 16775388
  HexColor_colorCrimson = 14423100
  HexColor_colorCyan = 65535
  HexColor_colorDarkBlue = 139
  HexColor_colorDarkCyan = 35723
  HexColor_colorDarkGoldenRod = 12092939
  HexColor_colorDarkGray = 11119017
  HexColor_colorDarkGreen = 25600
  HexColor_colorDarkKhaki = 12433259
  HexColor_colorDarkMagenta = 9109643
  HexColor_colorDarkOliveGreen = 5597999
  HexColor_colorDarkOrange = 16747520
  HexColor_colorDarkOrchid = 10040012
  HexColor_colorDarkRed = 9109504
  HexColor_colorDarkSalmon = 15308410
  HexColor_colorDarkSeaGreen = 9419919
  HexColor_colorDarkSlateBlue = 4734347
  HexColor_colorDarkSlateGray = 3100495
  HexColor_colorDarkTurquoise = 52945
  HexColor_colorDarkViolet = 9699539
  HexColor_colorDeepPink = 16716947
  HexColor_colorDeepSkyBlue = 49151
  HexColor_colorDimGray = 6908265
  HexColor_colorDodgerBlue = 2003199
  HexColor_colorFireBrick = 11674146
  HexColor_colorFloralWhite = 16775920
  HexColor_colorForestGreen = 2263842
  HexColor_colorFuchsia = 16711935
  HexColor_colorGainsboro = 14474460
  HexColor_colorGhostWhite = 16316671
  HexColor_colorGold = 16766720
  HexColor_colorGoldenRod = 14329120
  HexColor_colorGray = 8421504
  HexColor_colorGreen = 32768
  HexColor_colorGreenYellow = 11403055
  HexColor_colorHoneyDew = 15794160
  HexColor_colorHotPink = 16738740
  HexColor_colorIndianRed = 13458524
  HexColor_colorIndigo = 4915330
  HexColor_colorIvory = 16777200
  HexColor_colorKhaki = 15787660
  HexColor_colorLavender = 15132410
  HexColor_colorLavenderBlush = 16773365
  HexColor_colorLawnGreen = 8190976
  HexColor_colorLemonChiffon = 16775885
  HexColor_colorLightBlue = 11393254
  HexColor_colorLightCoral = 15761536
  HexColor_colorLightCyan = 14745599
  HexColor_colorLightGoldenRodYellow = 16448210
  HexColor_colorLightGray = 13882323
  HexColor_colorLightGreen = 9498256
  HexColor_colorLightPink = 16758465
  HexColor_colorLightSalmon = 16752762
  HexColor_colorLightSeaGreen = 2142890
  HexColor_colorLightSkyBlue = 8900346
  HexColor_colorLightSlateGray = 7833753
  HexColor_colorLightSteelBlue = 11584734
  HexColor_colorLightYellow = 16777184
  HexColor_colorLime = 65280
  HexColor_colorLimeGreen = 3329330
  HexColor_colorLinen = 16445670
  HexColor_colorMagenta = 16711935
  HexColor_colorMaroon = 8388608
  HexColor_colorMediumAquaMarine = 6737322
  HexColor_colorMediumBlue = 205
  HexColor_colorMediumOrchid = 12211667
  HexColor_colorMediumPurple = 9662683
  HexColor_colorMediumSeaGreen = 3978097
  HexColor_colorMediumSlateBlue = 8087790
  HexColor_colorMediumSpringGreen = 64154
  HexColor_colorMediumTurquoise = 4772300
  HexColor_colorMediumVioletRed = 13047173
  HexColor_colorMidnightBlue = 1644912
  HexColor_colorMintCream = 16121850
  HexColor_colorMistyRose = 16770273
  HexColor_colorMoccasin = 16770229
  HexColor_colorNavajoWhite = 16768685
  HexColor_colorNavy = 128
  HexColor_colorOldLace = 16643558
  HexColor_colorOlive = 8421376
  HexColor_colorOliveDrab = 7048739
  HexColor_colorOrange = 16753920
  HexColor_colorOrangeRed = 16729344
  HexColor_colorOrchid = 14315734
  HexColor_colorPaleGoldenRod = 15657130
  HexColor_colorPaleGreen = 10025880
  HexColor_colorPaleTurquoise = 11529966
  HexColor_colorPaleVioletRed = 14381203
  HexColor_colorPapayaWhip = 16773077
  HexColor_colorPeachPuff = 16767673
  HexColor_colorPeru = 13468991
  HexColor_colorPink = 16761035
  HexColor_colorPlum = 14524637
  HexColor_colorPowderBlue = 11591910
  HexColor_colorPurple = 8388736
  HexColor_colorRebeccaPurple = 6697881
  HexColor_colorRed = 16711680
  HexColor_colorRosyBrown = 12357519
  HexColor_colorRoyalBlue = 4286945
  HexColor_colorSaddleBrown = 9127187
  HexColor_colorSalmon = 16416882
  HexColor_colorSandyBrown = 16032864
  HexColor_colorSeaGreen = 3050327
  HexColor_colorSeaShell = 16774638
  HexColor_colorSienna = 10506797
  HexColor_colorSilver = 12632256
  HexColor_colorSkyBlue = 8900331
  HexColor_colorSlateBlue = 6970061
  HexColor_colorSlateGray = 7372944
  HexColor_colorSnow = 16775930
  HexColor_colorSpringGreen = 65407
  HexColor_colorSteelBlue = 4620980
  HexColor_colorTan = 13808780
  HexColor_colorTeal = 32896
  HexColor_colorThistle = 14204888
  HexColor_colorTomato = 16737095
  HexColor_colorTurquoise = 4251856
  HexColor_colorViolet = 15631086
  HexColor_colorWheat = 16113331
  HexColor_colorWhite = 16777215
  HexColor_colorWhiteSmoke = 16119285
  HexColor_colorYellow = 16776960
  HexColor_colorYellowGreen = 10145074
  HexColor_colorBox2DRed = 14430514
  HexColor_colorBox2DBlue = 3190463
  HexColor_colorBox2DGreen = 9226532
  HexColor_colorBox2DYellow = 16772748

  # Typedef

  typedef :pointer, :b2TaskCallback
  typedef :pointer, :b2EnqueueTaskCallback
  typedef :pointer, :b2FinishTaskCallback
  typedef :pointer, :b2FrictionCallback
  typedef :pointer, :b2RestitutionCallback
  typedef :int, :b2BodyType
  typedef :int, :b2ShapeType
  typedef :int, :b2JointType
  typedef :pointer, :b2CustomFilterFcn
  typedef :pointer, :b2PreSolveFcn
  typedef :pointer, :b2OverlapResultFcn
  typedef :pointer, :b2CastResultFcn
  typedef :int, :b2HexColor

  # Struct

  class RayResult < FFI::Struct
    layout(
      :shapeId, ShapeId,
      :point, Vec2,
      :normal, Vec2,
      :fraction, :float,
      :nodeVisits, :int,
      :leafVisits, :int,
      :hit, :bool,
    )
    def shapeId = self[:shapeId]
    def shapeId=(v) self[:shapeId] = v end
    def point = self[:point]
    def point=(v) self[:point] = v end
    def normal = self[:normal]
    def normal=(v) self[:normal] = v end
    def fraction = self[:fraction]
    def fraction=(v) self[:fraction] = v end
    def nodeVisits = self[:nodeVisits]
    def nodeVisits=(v) self[:nodeVisits] = v end
    def leafVisits = self[:leafVisits]
    def leafVisits=(v) self[:leafVisits] = v end
    def hit = self[:hit]
    def hit=(v) self[:hit] = v end
    def self.create_as(_shapeId_, _point_, _normal_, _fraction_, _nodeVisits_, _leafVisits_, _hit_)
      instance = RayResult.new
      instance[:shapeId] = _shapeId_
      instance[:point] = _point_
      instance[:normal] = _normal_
      instance[:fraction] = _fraction_
      instance[:nodeVisits] = _nodeVisits_
      instance[:leafVisits] = _leafVisits_
      instance[:hit] = _hit_
      instance
    end
  end

  class WorldDef < FFI::Struct
    layout(
      :gravity, Vec2,
      :restitutionThreshold, :float,
      :hitEventThreshold, :float,
      :contactHertz, :float,
      :contactDampingRatio, :float,
      :contactPushMaxSpeed, :float,
      :jointHertz, :float,
      :jointDampingRatio, :float,
      :maximumLinearSpeed, :float,
      :frictionCallback, :pointer,
      :restitutionCallback, :pointer,
      :enableSleep, :bool,
      :enableContinuous, :bool,
      :workerCount, :int,
      :enqueueTask, :pointer,
      :finishTask, :pointer,
      :userTaskContext, :pointer,
      :userData, :pointer,
      :internalValue, :int,
    )
    def gravity = self[:gravity]
    def gravity=(v) self[:gravity] = v end
    def restitutionThreshold = self[:restitutionThreshold]
    def restitutionThreshold=(v) self[:restitutionThreshold] = v end
    def hitEventThreshold = self[:hitEventThreshold]
    def hitEventThreshold=(v) self[:hitEventThreshold] = v end
    def contactHertz = self[:contactHertz]
    def contactHertz=(v) self[:contactHertz] = v end
    def contactDampingRatio = self[:contactDampingRatio]
    def contactDampingRatio=(v) self[:contactDampingRatio] = v end
    def contactPushMaxSpeed = self[:contactPushMaxSpeed]
    def contactPushMaxSpeed=(v) self[:contactPushMaxSpeed] = v end
    def jointHertz = self[:jointHertz]
    def jointHertz=(v) self[:jointHertz] = v end
    def jointDampingRatio = self[:jointDampingRatio]
    def jointDampingRatio=(v) self[:jointDampingRatio] = v end
    def maximumLinearSpeed = self[:maximumLinearSpeed]
    def maximumLinearSpeed=(v) self[:maximumLinearSpeed] = v end
    def frictionCallback = self[:frictionCallback]
    def frictionCallback=(v) self[:frictionCallback] = v end
    def restitutionCallback = self[:restitutionCallback]
    def restitutionCallback=(v) self[:restitutionCallback] = v end
    def enableSleep = self[:enableSleep]
    def enableSleep=(v) self[:enableSleep] = v end
    def enableContinuous = self[:enableContinuous]
    def enableContinuous=(v) self[:enableContinuous] = v end
    def workerCount = self[:workerCount]
    def workerCount=(v) self[:workerCount] = v end
    def enqueueTask = self[:enqueueTask]
    def enqueueTask=(v) self[:enqueueTask] = v end
    def finishTask = self[:finishTask]
    def finishTask=(v) self[:finishTask] = v end
    def userTaskContext = self[:userTaskContext]
    def userTaskContext=(v) self[:userTaskContext] = v end
    def userData = self[:userData]
    def userData=(v) self[:userData] = v end
    def internalValue = self[:internalValue]
    def internalValue=(v) self[:internalValue] = v end
    def self.create_as(_gravity_, _restitutionThreshold_, _hitEventThreshold_, _contactHertz_, _contactDampingRatio_, _contactPushMaxSpeed_, _jointHertz_, _jointDampingRatio_, _maximumLinearSpeed_, _frictionCallback_, _restitutionCallback_, _enableSleep_, _enableContinuous_, _workerCount_, _enqueueTask_, _finishTask_, _userTaskContext_, _userData_, _internalValue_)
      instance = WorldDef.new
      instance[:gravity] = _gravity_
      instance[:restitutionThreshold] = _restitutionThreshold_
      instance[:hitEventThreshold] = _hitEventThreshold_
      instance[:contactHertz] = _contactHertz_
      instance[:contactDampingRatio] = _contactDampingRatio_
      instance[:contactPushMaxSpeed] = _contactPushMaxSpeed_
      instance[:jointHertz] = _jointHertz_
      instance[:jointDampingRatio] = _jointDampingRatio_
      instance[:maximumLinearSpeed] = _maximumLinearSpeed_
      instance[:frictionCallback] = _frictionCallback_
      instance[:restitutionCallback] = _restitutionCallback_
      instance[:enableSleep] = _enableSleep_
      instance[:enableContinuous] = _enableContinuous_
      instance[:workerCount] = _workerCount_
      instance[:enqueueTask] = _enqueueTask_
      instance[:finishTask] = _finishTask_
      instance[:userTaskContext] = _userTaskContext_
      instance[:userData] = _userData_
      instance[:internalValue] = _internalValue_
      instance
    end
  end

  class BodyDef < FFI::Struct
    layout(
      :type, :int,
      :position, Vec2,
      :rotation, Rot,
      :linearVelocity, Vec2,
      :angularVelocity, :float,
      :linearDamping, :float,
      :angularDamping, :float,
      :gravityScale, :float,
      :sleepThreshold, :float,
      :name, :pointer,
      :userData, :pointer,
      :enableSleep, :bool,
      :isAwake, :bool,
      :fixedRotation, :bool,
      :isBullet, :bool,
      :isEnabled, :bool,
      :allowFastRotation, :bool,
      :internalValue, :int,
    )
    def type = self[:type]
    def type=(v) self[:type] = v end
    def position = self[:position]
    def position=(v) self[:position] = v end
    def rotation = self[:rotation]
    def rotation=(v) self[:rotation] = v end
    def linearVelocity = self[:linearVelocity]
    def linearVelocity=(v) self[:linearVelocity] = v end
    def angularVelocity = self[:angularVelocity]
    def angularVelocity=(v) self[:angularVelocity] = v end
    def linearDamping = self[:linearDamping]
    def linearDamping=(v) self[:linearDamping] = v end
    def angularDamping = self[:angularDamping]
    def angularDamping=(v) self[:angularDamping] = v end
    def gravityScale = self[:gravityScale]
    def gravityScale=(v) self[:gravityScale] = v end
    def sleepThreshold = self[:sleepThreshold]
    def sleepThreshold=(v) self[:sleepThreshold] = v end
    def name = self[:name]
    def name=(v) self[:name] = v end
    def userData = self[:userData]
    def userData=(v) self[:userData] = v end
    def enableSleep = self[:enableSleep]
    def enableSleep=(v) self[:enableSleep] = v end
    def isAwake = self[:isAwake]
    def isAwake=(v) self[:isAwake] = v end
    def fixedRotation = self[:fixedRotation]
    def fixedRotation=(v) self[:fixedRotation] = v end
    def isBullet = self[:isBullet]
    def isBullet=(v) self[:isBullet] = v end
    def isEnabled = self[:isEnabled]
    def isEnabled=(v) self[:isEnabled] = v end
    def allowFastRotation = self[:allowFastRotation]
    def allowFastRotation=(v) self[:allowFastRotation] = v end
    def internalValue = self[:internalValue]
    def internalValue=(v) self[:internalValue] = v end
    def self.create_as(_type_, _position_, _rotation_, _linearVelocity_, _angularVelocity_, _linearDamping_, _angularDamping_, _gravityScale_, _sleepThreshold_, _name_, _userData_, _enableSleep_, _isAwake_, _fixedRotation_, _isBullet_, _isEnabled_, _allowFastRotation_, _internalValue_)
      instance = BodyDef.new
      instance[:type] = _type_
      instance[:position] = _position_
      instance[:rotation] = _rotation_
      instance[:linearVelocity] = _linearVelocity_
      instance[:angularVelocity] = _angularVelocity_
      instance[:linearDamping] = _linearDamping_
      instance[:angularDamping] = _angularDamping_
      instance[:gravityScale] = _gravityScale_
      instance[:sleepThreshold] = _sleepThreshold_
      instance[:name] = _name_
      instance[:userData] = _userData_
      instance[:enableSleep] = _enableSleep_
      instance[:isAwake] = _isAwake_
      instance[:fixedRotation] = _fixedRotation_
      instance[:isBullet] = _isBullet_
      instance[:isEnabled] = _isEnabled_
      instance[:allowFastRotation] = _allowFastRotation_
      instance[:internalValue] = _internalValue_
      instance
    end
  end

  class Filter < FFI::Struct
    layout(
      :categoryBits, :ulong_long,
      :maskBits, :ulong_long,
      :groupIndex, :int,
    )
    def categoryBits = self[:categoryBits]
    def categoryBits=(v) self[:categoryBits] = v end
    def maskBits = self[:maskBits]
    def maskBits=(v) self[:maskBits] = v end
    def groupIndex = self[:groupIndex]
    def groupIndex=(v) self[:groupIndex] = v end
    def self.create_as(_categoryBits_, _maskBits_, _groupIndex_)
      instance = Filter.new
      instance[:categoryBits] = _categoryBits_
      instance[:maskBits] = _maskBits_
      instance[:groupIndex] = _groupIndex_
      instance
    end
  end

  class QueryFilter < FFI::Struct
    layout(
      :categoryBits, :ulong_long,
      :maskBits, :ulong_long,
    )
    def categoryBits = self[:categoryBits]
    def categoryBits=(v) self[:categoryBits] = v end
    def maskBits = self[:maskBits]
    def maskBits=(v) self[:maskBits] = v end
    def self.create_as(_categoryBits_, _maskBits_)
      instance = QueryFilter.new
      instance[:categoryBits] = _categoryBits_
      instance[:maskBits] = _maskBits_
      instance
    end
  end

  class ShapeDef < FFI::Struct
    layout(
      :userData, :pointer,
      :friction, :float,
      :restitution, :float,
      :rollingResistance, :float,
      :tangentSpeed, :float,
      :material, :int,
      :density, :float,
      :filter, Filter,
      :customColor, :uint,
      :isSensor, :bool,
      :enableContactEvents, :bool,
      :enableHitEvents, :bool,
      :enablePreSolveEvents, :bool,
      :invokeContactCreation, :bool,
      :updateBodyMass, :bool,
      :internalValue, :int,
    )
    def userData = self[:userData]
    def userData=(v) self[:userData] = v end
    def friction = self[:friction]
    def friction=(v) self[:friction] = v end
    def restitution = self[:restitution]
    def restitution=(v) self[:restitution] = v end
    def rollingResistance = self[:rollingResistance]
    def rollingResistance=(v) self[:rollingResistance] = v end
    def tangentSpeed = self[:tangentSpeed]
    def tangentSpeed=(v) self[:tangentSpeed] = v end
    def material = self[:material]
    def material=(v) self[:material] = v end
    def density = self[:density]
    def density=(v) self[:density] = v end
    def filter = self[:filter]
    def filter=(v) self[:filter] = v end
    def customColor = self[:customColor]
    def customColor=(v) self[:customColor] = v end
    def isSensor = self[:isSensor]
    def isSensor=(v) self[:isSensor] = v end
    def enableContactEvents = self[:enableContactEvents]
    def enableContactEvents=(v) self[:enableContactEvents] = v end
    def enableHitEvents = self[:enableHitEvents]
    def enableHitEvents=(v) self[:enableHitEvents] = v end
    def enablePreSolveEvents = self[:enablePreSolveEvents]
    def enablePreSolveEvents=(v) self[:enablePreSolveEvents] = v end
    def invokeContactCreation = self[:invokeContactCreation]
    def invokeContactCreation=(v) self[:invokeContactCreation] = v end
    def updateBodyMass = self[:updateBodyMass]
    def updateBodyMass=(v) self[:updateBodyMass] = v end
    def internalValue = self[:internalValue]
    def internalValue=(v) self[:internalValue] = v end
    def self.create_as(_userData_, _friction_, _restitution_, _rollingResistance_, _tangentSpeed_, _material_, _density_, _filter_, _customColor_, _isSensor_, _enableContactEvents_, _enableHitEvents_, _enablePreSolveEvents_, _invokeContactCreation_, _updateBodyMass_, _internalValue_)
      instance = ShapeDef.new
      instance[:userData] = _userData_
      instance[:friction] = _friction_
      instance[:restitution] = _restitution_
      instance[:rollingResistance] = _rollingResistance_
      instance[:tangentSpeed] = _tangentSpeed_
      instance[:material] = _material_
      instance[:density] = _density_
      instance[:filter] = _filter_
      instance[:customColor] = _customColor_
      instance[:isSensor] = _isSensor_
      instance[:enableContactEvents] = _enableContactEvents_
      instance[:enableHitEvents] = _enableHitEvents_
      instance[:enablePreSolveEvents] = _enablePreSolveEvents_
      instance[:invokeContactCreation] = _invokeContactCreation_
      instance[:updateBodyMass] = _updateBodyMass_
      instance[:internalValue] = _internalValue_
      instance
    end
  end

  class SurfaceMaterial < FFI::Struct
    layout(
      :friction, :float,
      :restitution, :float,
      :rollingResistance, :float,
      :tangentSpeed, :float,
      :material, :int,
      :customColor, :uint,
    )
    def friction = self[:friction]
    def friction=(v) self[:friction] = v end
    def restitution = self[:restitution]
    def restitution=(v) self[:restitution] = v end
    def rollingResistance = self[:rollingResistance]
    def rollingResistance=(v) self[:rollingResistance] = v end
    def tangentSpeed = self[:tangentSpeed]
    def tangentSpeed=(v) self[:tangentSpeed] = v end
    def material = self[:material]
    def material=(v) self[:material] = v end
    def customColor = self[:customColor]
    def customColor=(v) self[:customColor] = v end
    def self.create_as(_friction_, _restitution_, _rollingResistance_, _tangentSpeed_, _material_, _customColor_)
      instance = SurfaceMaterial.new
      instance[:friction] = _friction_
      instance[:restitution] = _restitution_
      instance[:rollingResistance] = _rollingResistance_
      instance[:tangentSpeed] = _tangentSpeed_
      instance[:material] = _material_
      instance[:customColor] = _customColor_
      instance
    end
  end

  class ChainDef < FFI::Struct
    layout(
      :userData, :pointer,
      :points, :pointer,
      :count, :int,
      :materials, :pointer,
      :materialCount, :int,
      :filter, Filter,
      :isLoop, :bool,
      :internalValue, :int,
    )
    def userData = self[:userData]
    def userData=(v) self[:userData] = v end
    def points = self[:points]
    def points=(v) self[:points] = v end
    def count = self[:count]
    def count=(v) self[:count] = v end
    def materials = self[:materials]
    def materials=(v) self[:materials] = v end
    def materialCount = self[:materialCount]
    def materialCount=(v) self[:materialCount] = v end
    def filter = self[:filter]
    def filter=(v) self[:filter] = v end
    def isLoop = self[:isLoop]
    def isLoop=(v) self[:isLoop] = v end
    def internalValue = self[:internalValue]
    def internalValue=(v) self[:internalValue] = v end
    def self.create_as(_userData_, _points_, _count_, _materials_, _materialCount_, _filter_, _isLoop_, _internalValue_)
      instance = ChainDef.new
      instance[:userData] = _userData_
      instance[:points] = _points_
      instance[:count] = _count_
      instance[:materials] = _materials_
      instance[:materialCount] = _materialCount_
      instance[:filter] = _filter_
      instance[:isLoop] = _isLoop_
      instance[:internalValue] = _internalValue_
      instance
    end
  end

  class Profile < FFI::Struct
    layout(
      :step, :float,
      :pairs, :float,
      :collide, :float,
      :solve, :float,
      :mergeIslands, :float,
      :prepareStages, :float,
      :solveConstraints, :float,
      :prepareConstraints, :float,
      :integrateVelocities, :float,
      :warmStart, :float,
      :solveImpulses, :float,
      :integratePositions, :float,
      :relaxImpulses, :float,
      :applyRestitution, :float,
      :storeImpulses, :float,
      :splitIslands, :float,
      :transforms, :float,
      :hitEvents, :float,
      :refit, :float,
      :bullets, :float,
      :sleepIslands, :float,
      :sensors, :float,
    )
    def step = self[:step]
    def step=(v) self[:step] = v end
    def pairs = self[:pairs]
    def pairs=(v) self[:pairs] = v end
    def collide = self[:collide]
    def collide=(v) self[:collide] = v end
    def solve = self[:solve]
    def solve=(v) self[:solve] = v end
    def mergeIslands = self[:mergeIslands]
    def mergeIslands=(v) self[:mergeIslands] = v end
    def prepareStages = self[:prepareStages]
    def prepareStages=(v) self[:prepareStages] = v end
    def solveConstraints = self[:solveConstraints]
    def solveConstraints=(v) self[:solveConstraints] = v end
    def prepareConstraints = self[:prepareConstraints]
    def prepareConstraints=(v) self[:prepareConstraints] = v end
    def integrateVelocities = self[:integrateVelocities]
    def integrateVelocities=(v) self[:integrateVelocities] = v end
    def warmStart = self[:warmStart]
    def warmStart=(v) self[:warmStart] = v end
    def solveImpulses = self[:solveImpulses]
    def solveImpulses=(v) self[:solveImpulses] = v end
    def integratePositions = self[:integratePositions]
    def integratePositions=(v) self[:integratePositions] = v end
    def relaxImpulses = self[:relaxImpulses]
    def relaxImpulses=(v) self[:relaxImpulses] = v end
    def applyRestitution = self[:applyRestitution]
    def applyRestitution=(v) self[:applyRestitution] = v end
    def storeImpulses = self[:storeImpulses]
    def storeImpulses=(v) self[:storeImpulses] = v end
    def splitIslands = self[:splitIslands]
    def splitIslands=(v) self[:splitIslands] = v end
    def transforms = self[:transforms]
    def transforms=(v) self[:transforms] = v end
    def hitEvents = self[:hitEvents]
    def hitEvents=(v) self[:hitEvents] = v end
    def refit = self[:refit]
    def refit=(v) self[:refit] = v end
    def bullets = self[:bullets]
    def bullets=(v) self[:bullets] = v end
    def sleepIslands = self[:sleepIslands]
    def sleepIslands=(v) self[:sleepIslands] = v end
    def sensors = self[:sensors]
    def sensors=(v) self[:sensors] = v end
    def self.create_as(_step_, _pairs_, _collide_, _solve_, _mergeIslands_, _prepareStages_, _solveConstraints_, _prepareConstraints_, _integrateVelocities_, _warmStart_, _solveImpulses_, _integratePositions_, _relaxImpulses_, _applyRestitution_, _storeImpulses_, _splitIslands_, _transforms_, _hitEvents_, _refit_, _bullets_, _sleepIslands_, _sensors_)
      instance = Profile.new
      instance[:step] = _step_
      instance[:pairs] = _pairs_
      instance[:collide] = _collide_
      instance[:solve] = _solve_
      instance[:mergeIslands] = _mergeIslands_
      instance[:prepareStages] = _prepareStages_
      instance[:solveConstraints] = _solveConstraints_
      instance[:prepareConstraints] = _prepareConstraints_
      instance[:integrateVelocities] = _integrateVelocities_
      instance[:warmStart] = _warmStart_
      instance[:solveImpulses] = _solveImpulses_
      instance[:integratePositions] = _integratePositions_
      instance[:relaxImpulses] = _relaxImpulses_
      instance[:applyRestitution] = _applyRestitution_
      instance[:storeImpulses] = _storeImpulses_
      instance[:splitIslands] = _splitIslands_
      instance[:transforms] = _transforms_
      instance[:hitEvents] = _hitEvents_
      instance[:refit] = _refit_
      instance[:bullets] = _bullets_
      instance[:sleepIslands] = _sleepIslands_
      instance[:sensors] = _sensors_
      instance
    end
  end

  class Counters < FFI::Struct
    layout(
      :bodyCount, :int,
      :shapeCount, :int,
      :contactCount, :int,
      :jointCount, :int,
      :islandCount, :int,
      :stackUsed, :int,
      :staticTreeHeight, :int,
      :treeHeight, :int,
      :byteCount, :int,
      :taskCount, :int,
      :colorCounts, [:int, 12],
    )
    def bodyCount = self[:bodyCount]
    def bodyCount=(v) self[:bodyCount] = v end
    def shapeCount = self[:shapeCount]
    def shapeCount=(v) self[:shapeCount] = v end
    def contactCount = self[:contactCount]
    def contactCount=(v) self[:contactCount] = v end
    def jointCount = self[:jointCount]
    def jointCount=(v) self[:jointCount] = v end
    def islandCount = self[:islandCount]
    def islandCount=(v) self[:islandCount] = v end
    def stackUsed = self[:stackUsed]
    def stackUsed=(v) self[:stackUsed] = v end
    def staticTreeHeight = self[:staticTreeHeight]
    def staticTreeHeight=(v) self[:staticTreeHeight] = v end
    def treeHeight = self[:treeHeight]
    def treeHeight=(v) self[:treeHeight] = v end
    def byteCount = self[:byteCount]
    def byteCount=(v) self[:byteCount] = v end
    def taskCount = self[:taskCount]
    def taskCount=(v) self[:taskCount] = v end
    def colorCounts = self[:colorCounts]
    def colorCounts=(v) self[:colorCounts] = v end
    def self.create_as(_bodyCount_, _shapeCount_, _contactCount_, _jointCount_, _islandCount_, _stackUsed_, _staticTreeHeight_, _treeHeight_, _byteCount_, _taskCount_, _colorCounts_)
      instance = Counters.new
      instance[:bodyCount] = _bodyCount_
      instance[:shapeCount] = _shapeCount_
      instance[:contactCount] = _contactCount_
      instance[:jointCount] = _jointCount_
      instance[:islandCount] = _islandCount_
      instance[:stackUsed] = _stackUsed_
      instance[:staticTreeHeight] = _staticTreeHeight_
      instance[:treeHeight] = _treeHeight_
      instance[:byteCount] = _byteCount_
      instance[:taskCount] = _taskCount_
      instance[:colorCounts] = _colorCounts_
      instance
    end
  end

  class DistanceJointDef < FFI::Struct
    layout(
      :bodyIdA, BodyId,
      :bodyIdB, BodyId,
      :localAnchorA, Vec2,
      :localAnchorB, Vec2,
      :length, :float,
      :enableSpring, :bool,
      :hertz, :float,
      :dampingRatio, :float,
      :enableLimit, :bool,
      :minLength, :float,
      :maxLength, :float,
      :enableMotor, :bool,
      :maxMotorForce, :float,
      :motorSpeed, :float,
      :collideConnected, :bool,
      :userData, :pointer,
      :internalValue, :int,
    )
    def bodyIdA = self[:bodyIdA]
    def bodyIdA=(v) self[:bodyIdA] = v end
    def bodyIdB = self[:bodyIdB]
    def bodyIdB=(v) self[:bodyIdB] = v end
    def localAnchorA = self[:localAnchorA]
    def localAnchorA=(v) self[:localAnchorA] = v end
    def localAnchorB = self[:localAnchorB]
    def localAnchorB=(v) self[:localAnchorB] = v end
    def length = self[:length]
    def length=(v) self[:length] = v end
    def enableSpring = self[:enableSpring]
    def enableSpring=(v) self[:enableSpring] = v end
    def hertz = self[:hertz]
    def hertz=(v) self[:hertz] = v end
    def dampingRatio = self[:dampingRatio]
    def dampingRatio=(v) self[:dampingRatio] = v end
    def enableLimit = self[:enableLimit]
    def enableLimit=(v) self[:enableLimit] = v end
    def minLength = self[:minLength]
    def minLength=(v) self[:minLength] = v end
    def maxLength = self[:maxLength]
    def maxLength=(v) self[:maxLength] = v end
    def enableMotor = self[:enableMotor]
    def enableMotor=(v) self[:enableMotor] = v end
    def maxMotorForce = self[:maxMotorForce]
    def maxMotorForce=(v) self[:maxMotorForce] = v end
    def motorSpeed = self[:motorSpeed]
    def motorSpeed=(v) self[:motorSpeed] = v end
    def collideConnected = self[:collideConnected]
    def collideConnected=(v) self[:collideConnected] = v end
    def userData = self[:userData]
    def userData=(v) self[:userData] = v end
    def internalValue = self[:internalValue]
    def internalValue=(v) self[:internalValue] = v end
    def self.create_as(_bodyIdA_, _bodyIdB_, _localAnchorA_, _localAnchorB_, _length_, _enableSpring_, _hertz_, _dampingRatio_, _enableLimit_, _minLength_, _maxLength_, _enableMotor_, _maxMotorForce_, _motorSpeed_, _collideConnected_, _userData_, _internalValue_)
      instance = DistanceJointDef.new
      instance[:bodyIdA] = _bodyIdA_
      instance[:bodyIdB] = _bodyIdB_
      instance[:localAnchorA] = _localAnchorA_
      instance[:localAnchorB] = _localAnchorB_
      instance[:length] = _length_
      instance[:enableSpring] = _enableSpring_
      instance[:hertz] = _hertz_
      instance[:dampingRatio] = _dampingRatio_
      instance[:enableLimit] = _enableLimit_
      instance[:minLength] = _minLength_
      instance[:maxLength] = _maxLength_
      instance[:enableMotor] = _enableMotor_
      instance[:maxMotorForce] = _maxMotorForce_
      instance[:motorSpeed] = _motorSpeed_
      instance[:collideConnected] = _collideConnected_
      instance[:userData] = _userData_
      instance[:internalValue] = _internalValue_
      instance
    end
  end

  class MotorJointDef < FFI::Struct
    layout(
      :bodyIdA, BodyId,
      :bodyIdB, BodyId,
      :linearOffset, Vec2,
      :angularOffset, :float,
      :maxForce, :float,
      :maxTorque, :float,
      :correctionFactor, :float,
      :collideConnected, :bool,
      :userData, :pointer,
      :internalValue, :int,
    )
    def bodyIdA = self[:bodyIdA]
    def bodyIdA=(v) self[:bodyIdA] = v end
    def bodyIdB = self[:bodyIdB]
    def bodyIdB=(v) self[:bodyIdB] = v end
    def linearOffset = self[:linearOffset]
    def linearOffset=(v) self[:linearOffset] = v end
    def angularOffset = self[:angularOffset]
    def angularOffset=(v) self[:angularOffset] = v end
    def maxForce = self[:maxForce]
    def maxForce=(v) self[:maxForce] = v end
    def maxTorque = self[:maxTorque]
    def maxTorque=(v) self[:maxTorque] = v end
    def correctionFactor = self[:correctionFactor]
    def correctionFactor=(v) self[:correctionFactor] = v end
    def collideConnected = self[:collideConnected]
    def collideConnected=(v) self[:collideConnected] = v end
    def userData = self[:userData]
    def userData=(v) self[:userData] = v end
    def internalValue = self[:internalValue]
    def internalValue=(v) self[:internalValue] = v end
    def self.create_as(_bodyIdA_, _bodyIdB_, _linearOffset_, _angularOffset_, _maxForce_, _maxTorque_, _correctionFactor_, _collideConnected_, _userData_, _internalValue_)
      instance = MotorJointDef.new
      instance[:bodyIdA] = _bodyIdA_
      instance[:bodyIdB] = _bodyIdB_
      instance[:linearOffset] = _linearOffset_
      instance[:angularOffset] = _angularOffset_
      instance[:maxForce] = _maxForce_
      instance[:maxTorque] = _maxTorque_
      instance[:correctionFactor] = _correctionFactor_
      instance[:collideConnected] = _collideConnected_
      instance[:userData] = _userData_
      instance[:internalValue] = _internalValue_
      instance
    end
  end

  class MouseJointDef < FFI::Struct
    layout(
      :bodyIdA, BodyId,
      :bodyIdB, BodyId,
      :target, Vec2,
      :hertz, :float,
      :dampingRatio, :float,
      :maxForce, :float,
      :collideConnected, :bool,
      :userData, :pointer,
      :internalValue, :int,
    )
    def bodyIdA = self[:bodyIdA]
    def bodyIdA=(v) self[:bodyIdA] = v end
    def bodyIdB = self[:bodyIdB]
    def bodyIdB=(v) self[:bodyIdB] = v end
    def target = self[:target]
    def target=(v) self[:target] = v end
    def hertz = self[:hertz]
    def hertz=(v) self[:hertz] = v end
    def dampingRatio = self[:dampingRatio]
    def dampingRatio=(v) self[:dampingRatio] = v end
    def maxForce = self[:maxForce]
    def maxForce=(v) self[:maxForce] = v end
    def collideConnected = self[:collideConnected]
    def collideConnected=(v) self[:collideConnected] = v end
    def userData = self[:userData]
    def userData=(v) self[:userData] = v end
    def internalValue = self[:internalValue]
    def internalValue=(v) self[:internalValue] = v end
    def self.create_as(_bodyIdA_, _bodyIdB_, _target_, _hertz_, _dampingRatio_, _maxForce_, _collideConnected_, _userData_, _internalValue_)
      instance = MouseJointDef.new
      instance[:bodyIdA] = _bodyIdA_
      instance[:bodyIdB] = _bodyIdB_
      instance[:target] = _target_
      instance[:hertz] = _hertz_
      instance[:dampingRatio] = _dampingRatio_
      instance[:maxForce] = _maxForce_
      instance[:collideConnected] = _collideConnected_
      instance[:userData] = _userData_
      instance[:internalValue] = _internalValue_
      instance
    end
  end

  class NullJointDef < FFI::Struct
    layout(
      :bodyIdA, BodyId,
      :bodyIdB, BodyId,
      :userData, :pointer,
      :internalValue, :int,
    )
    def bodyIdA = self[:bodyIdA]
    def bodyIdA=(v) self[:bodyIdA] = v end
    def bodyIdB = self[:bodyIdB]
    def bodyIdB=(v) self[:bodyIdB] = v end
    def userData = self[:userData]
    def userData=(v) self[:userData] = v end
    def internalValue = self[:internalValue]
    def internalValue=(v) self[:internalValue] = v end
    def self.create_as(_bodyIdA_, _bodyIdB_, _userData_, _internalValue_)
      instance = NullJointDef.new
      instance[:bodyIdA] = _bodyIdA_
      instance[:bodyIdB] = _bodyIdB_
      instance[:userData] = _userData_
      instance[:internalValue] = _internalValue_
      instance
    end
  end

  class PrismaticJointDef < FFI::Struct
    layout(
      :bodyIdA, BodyId,
      :bodyIdB, BodyId,
      :localAnchorA, Vec2,
      :localAnchorB, Vec2,
      :localAxisA, Vec2,
      :referenceAngle, :float,
      :enableSpring, :bool,
      :hertz, :float,
      :dampingRatio, :float,
      :enableLimit, :bool,
      :lowerTranslation, :float,
      :upperTranslation, :float,
      :enableMotor, :bool,
      :maxMotorForce, :float,
      :motorSpeed, :float,
      :collideConnected, :bool,
      :userData, :pointer,
      :internalValue, :int,
    )
    def bodyIdA = self[:bodyIdA]
    def bodyIdA=(v) self[:bodyIdA] = v end
    def bodyIdB = self[:bodyIdB]
    def bodyIdB=(v) self[:bodyIdB] = v end
    def localAnchorA = self[:localAnchorA]
    def localAnchorA=(v) self[:localAnchorA] = v end
    def localAnchorB = self[:localAnchorB]
    def localAnchorB=(v) self[:localAnchorB] = v end
    def localAxisA = self[:localAxisA]
    def localAxisA=(v) self[:localAxisA] = v end
    def referenceAngle = self[:referenceAngle]
    def referenceAngle=(v) self[:referenceAngle] = v end
    def enableSpring = self[:enableSpring]
    def enableSpring=(v) self[:enableSpring] = v end
    def hertz = self[:hertz]
    def hertz=(v) self[:hertz] = v end
    def dampingRatio = self[:dampingRatio]
    def dampingRatio=(v) self[:dampingRatio] = v end
    def enableLimit = self[:enableLimit]
    def enableLimit=(v) self[:enableLimit] = v end
    def lowerTranslation = self[:lowerTranslation]
    def lowerTranslation=(v) self[:lowerTranslation] = v end
    def upperTranslation = self[:upperTranslation]
    def upperTranslation=(v) self[:upperTranslation] = v end
    def enableMotor = self[:enableMotor]
    def enableMotor=(v) self[:enableMotor] = v end
    def maxMotorForce = self[:maxMotorForce]
    def maxMotorForce=(v) self[:maxMotorForce] = v end
    def motorSpeed = self[:motorSpeed]
    def motorSpeed=(v) self[:motorSpeed] = v end
    def collideConnected = self[:collideConnected]
    def collideConnected=(v) self[:collideConnected] = v end
    def userData = self[:userData]
    def userData=(v) self[:userData] = v end
    def internalValue = self[:internalValue]
    def internalValue=(v) self[:internalValue] = v end
    def self.create_as(_bodyIdA_, _bodyIdB_, _localAnchorA_, _localAnchorB_, _localAxisA_, _referenceAngle_, _enableSpring_, _hertz_, _dampingRatio_, _enableLimit_, _lowerTranslation_, _upperTranslation_, _enableMotor_, _maxMotorForce_, _motorSpeed_, _collideConnected_, _userData_, _internalValue_)
      instance = PrismaticJointDef.new
      instance[:bodyIdA] = _bodyIdA_
      instance[:bodyIdB] = _bodyIdB_
      instance[:localAnchorA] = _localAnchorA_
      instance[:localAnchorB] = _localAnchorB_
      instance[:localAxisA] = _localAxisA_
      instance[:referenceAngle] = _referenceAngle_
      instance[:enableSpring] = _enableSpring_
      instance[:hertz] = _hertz_
      instance[:dampingRatio] = _dampingRatio_
      instance[:enableLimit] = _enableLimit_
      instance[:lowerTranslation] = _lowerTranslation_
      instance[:upperTranslation] = _upperTranslation_
      instance[:enableMotor] = _enableMotor_
      instance[:maxMotorForce] = _maxMotorForce_
      instance[:motorSpeed] = _motorSpeed_
      instance[:collideConnected] = _collideConnected_
      instance[:userData] = _userData_
      instance[:internalValue] = _internalValue_
      instance
    end
  end

  class RevoluteJointDef < FFI::Struct
    layout(
      :bodyIdA, BodyId,
      :bodyIdB, BodyId,
      :localAnchorA, Vec2,
      :localAnchorB, Vec2,
      :referenceAngle, :float,
      :enableSpring, :bool,
      :hertz, :float,
      :dampingRatio, :float,
      :enableLimit, :bool,
      :lowerAngle, :float,
      :upperAngle, :float,
      :enableMotor, :bool,
      :maxMotorTorque, :float,
      :motorSpeed, :float,
      :drawSize, :float,
      :collideConnected, :bool,
      :userData, :pointer,
      :internalValue, :int,
    )
    def bodyIdA = self[:bodyIdA]
    def bodyIdA=(v) self[:bodyIdA] = v end
    def bodyIdB = self[:bodyIdB]
    def bodyIdB=(v) self[:bodyIdB] = v end
    def localAnchorA = self[:localAnchorA]
    def localAnchorA=(v) self[:localAnchorA] = v end
    def localAnchorB = self[:localAnchorB]
    def localAnchorB=(v) self[:localAnchorB] = v end
    def referenceAngle = self[:referenceAngle]
    def referenceAngle=(v) self[:referenceAngle] = v end
    def enableSpring = self[:enableSpring]
    def enableSpring=(v) self[:enableSpring] = v end
    def hertz = self[:hertz]
    def hertz=(v) self[:hertz] = v end
    def dampingRatio = self[:dampingRatio]
    def dampingRatio=(v) self[:dampingRatio] = v end
    def enableLimit = self[:enableLimit]
    def enableLimit=(v) self[:enableLimit] = v end
    def lowerAngle = self[:lowerAngle]
    def lowerAngle=(v) self[:lowerAngle] = v end
    def upperAngle = self[:upperAngle]
    def upperAngle=(v) self[:upperAngle] = v end
    def enableMotor = self[:enableMotor]
    def enableMotor=(v) self[:enableMotor] = v end
    def maxMotorTorque = self[:maxMotorTorque]
    def maxMotorTorque=(v) self[:maxMotorTorque] = v end
    def motorSpeed = self[:motorSpeed]
    def motorSpeed=(v) self[:motorSpeed] = v end
    def drawSize = self[:drawSize]
    def drawSize=(v) self[:drawSize] = v end
    def collideConnected = self[:collideConnected]
    def collideConnected=(v) self[:collideConnected] = v end
    def userData = self[:userData]
    def userData=(v) self[:userData] = v end
    def internalValue = self[:internalValue]
    def internalValue=(v) self[:internalValue] = v end
    def self.create_as(_bodyIdA_, _bodyIdB_, _localAnchorA_, _localAnchorB_, _referenceAngle_, _enableSpring_, _hertz_, _dampingRatio_, _enableLimit_, _lowerAngle_, _upperAngle_, _enableMotor_, _maxMotorTorque_, _motorSpeed_, _drawSize_, _collideConnected_, _userData_, _internalValue_)
      instance = RevoluteJointDef.new
      instance[:bodyIdA] = _bodyIdA_
      instance[:bodyIdB] = _bodyIdB_
      instance[:localAnchorA] = _localAnchorA_
      instance[:localAnchorB] = _localAnchorB_
      instance[:referenceAngle] = _referenceAngle_
      instance[:enableSpring] = _enableSpring_
      instance[:hertz] = _hertz_
      instance[:dampingRatio] = _dampingRatio_
      instance[:enableLimit] = _enableLimit_
      instance[:lowerAngle] = _lowerAngle_
      instance[:upperAngle] = _upperAngle_
      instance[:enableMotor] = _enableMotor_
      instance[:maxMotorTorque] = _maxMotorTorque_
      instance[:motorSpeed] = _motorSpeed_
      instance[:drawSize] = _drawSize_
      instance[:collideConnected] = _collideConnected_
      instance[:userData] = _userData_
      instance[:internalValue] = _internalValue_
      instance
    end
  end

  class WeldJointDef < FFI::Struct
    layout(
      :bodyIdA, BodyId,
      :bodyIdB, BodyId,
      :localAnchorA, Vec2,
      :localAnchorB, Vec2,
      :referenceAngle, :float,
      :linearHertz, :float,
      :angularHertz, :float,
      :linearDampingRatio, :float,
      :angularDampingRatio, :float,
      :collideConnected, :bool,
      :userData, :pointer,
      :internalValue, :int,
    )
    def bodyIdA = self[:bodyIdA]
    def bodyIdA=(v) self[:bodyIdA] = v end
    def bodyIdB = self[:bodyIdB]
    def bodyIdB=(v) self[:bodyIdB] = v end
    def localAnchorA = self[:localAnchorA]
    def localAnchorA=(v) self[:localAnchorA] = v end
    def localAnchorB = self[:localAnchorB]
    def localAnchorB=(v) self[:localAnchorB] = v end
    def referenceAngle = self[:referenceAngle]
    def referenceAngle=(v) self[:referenceAngle] = v end
    def linearHertz = self[:linearHertz]
    def linearHertz=(v) self[:linearHertz] = v end
    def angularHertz = self[:angularHertz]
    def angularHertz=(v) self[:angularHertz] = v end
    def linearDampingRatio = self[:linearDampingRatio]
    def linearDampingRatio=(v) self[:linearDampingRatio] = v end
    def angularDampingRatio = self[:angularDampingRatio]
    def angularDampingRatio=(v) self[:angularDampingRatio] = v end
    def collideConnected = self[:collideConnected]
    def collideConnected=(v) self[:collideConnected] = v end
    def userData = self[:userData]
    def userData=(v) self[:userData] = v end
    def internalValue = self[:internalValue]
    def internalValue=(v) self[:internalValue] = v end
    def self.create_as(_bodyIdA_, _bodyIdB_, _localAnchorA_, _localAnchorB_, _referenceAngle_, _linearHertz_, _angularHertz_, _linearDampingRatio_, _angularDampingRatio_, _collideConnected_, _userData_, _internalValue_)
      instance = WeldJointDef.new
      instance[:bodyIdA] = _bodyIdA_
      instance[:bodyIdB] = _bodyIdB_
      instance[:localAnchorA] = _localAnchorA_
      instance[:localAnchorB] = _localAnchorB_
      instance[:referenceAngle] = _referenceAngle_
      instance[:linearHertz] = _linearHertz_
      instance[:angularHertz] = _angularHertz_
      instance[:linearDampingRatio] = _linearDampingRatio_
      instance[:angularDampingRatio] = _angularDampingRatio_
      instance[:collideConnected] = _collideConnected_
      instance[:userData] = _userData_
      instance[:internalValue] = _internalValue_
      instance
    end
  end

  class WheelJointDef < FFI::Struct
    layout(
      :bodyIdA, BodyId,
      :bodyIdB, BodyId,
      :localAnchorA, Vec2,
      :localAnchorB, Vec2,
      :localAxisA, Vec2,
      :enableSpring, :bool,
      :hertz, :float,
      :dampingRatio, :float,
      :enableLimit, :bool,
      :lowerTranslation, :float,
      :upperTranslation, :float,
      :enableMotor, :bool,
      :maxMotorTorque, :float,
      :motorSpeed, :float,
      :collideConnected, :bool,
      :userData, :pointer,
      :internalValue, :int,
    )
    def bodyIdA = self[:bodyIdA]
    def bodyIdA=(v) self[:bodyIdA] = v end
    def bodyIdB = self[:bodyIdB]
    def bodyIdB=(v) self[:bodyIdB] = v end
    def localAnchorA = self[:localAnchorA]
    def localAnchorA=(v) self[:localAnchorA] = v end
    def localAnchorB = self[:localAnchorB]
    def localAnchorB=(v) self[:localAnchorB] = v end
    def localAxisA = self[:localAxisA]
    def localAxisA=(v) self[:localAxisA] = v end
    def enableSpring = self[:enableSpring]
    def enableSpring=(v) self[:enableSpring] = v end
    def hertz = self[:hertz]
    def hertz=(v) self[:hertz] = v end
    def dampingRatio = self[:dampingRatio]
    def dampingRatio=(v) self[:dampingRatio] = v end
    def enableLimit = self[:enableLimit]
    def enableLimit=(v) self[:enableLimit] = v end
    def lowerTranslation = self[:lowerTranslation]
    def lowerTranslation=(v) self[:lowerTranslation] = v end
    def upperTranslation = self[:upperTranslation]
    def upperTranslation=(v) self[:upperTranslation] = v end
    def enableMotor = self[:enableMotor]
    def enableMotor=(v) self[:enableMotor] = v end
    def maxMotorTorque = self[:maxMotorTorque]
    def maxMotorTorque=(v) self[:maxMotorTorque] = v end
    def motorSpeed = self[:motorSpeed]
    def motorSpeed=(v) self[:motorSpeed] = v end
    def collideConnected = self[:collideConnected]
    def collideConnected=(v) self[:collideConnected] = v end
    def userData = self[:userData]
    def userData=(v) self[:userData] = v end
    def internalValue = self[:internalValue]
    def internalValue=(v) self[:internalValue] = v end
    def self.create_as(_bodyIdA_, _bodyIdB_, _localAnchorA_, _localAnchorB_, _localAxisA_, _enableSpring_, _hertz_, _dampingRatio_, _enableLimit_, _lowerTranslation_, _upperTranslation_, _enableMotor_, _maxMotorTorque_, _motorSpeed_, _collideConnected_, _userData_, _internalValue_)
      instance = WheelJointDef.new
      instance[:bodyIdA] = _bodyIdA_
      instance[:bodyIdB] = _bodyIdB_
      instance[:localAnchorA] = _localAnchorA_
      instance[:localAnchorB] = _localAnchorB_
      instance[:localAxisA] = _localAxisA_
      instance[:enableSpring] = _enableSpring_
      instance[:hertz] = _hertz_
      instance[:dampingRatio] = _dampingRatio_
      instance[:enableLimit] = _enableLimit_
      instance[:lowerTranslation] = _lowerTranslation_
      instance[:upperTranslation] = _upperTranslation_
      instance[:enableMotor] = _enableMotor_
      instance[:maxMotorTorque] = _maxMotorTorque_
      instance[:motorSpeed] = _motorSpeed_
      instance[:collideConnected] = _collideConnected_
      instance[:userData] = _userData_
      instance[:internalValue] = _internalValue_
      instance
    end
  end

  class ExplosionDef < FFI::Struct
    layout(
      :maskBits, :ulong_long,
      :position, Vec2,
      :radius, :float,
      :falloff, :float,
      :impulsePerLength, :float,
    )
    def maskBits = self[:maskBits]
    def maskBits=(v) self[:maskBits] = v end
    def position = self[:position]
    def position=(v) self[:position] = v end
    def radius = self[:radius]
    def radius=(v) self[:radius] = v end
    def falloff = self[:falloff]
    def falloff=(v) self[:falloff] = v end
    def impulsePerLength = self[:impulsePerLength]
    def impulsePerLength=(v) self[:impulsePerLength] = v end
    def self.create_as(_maskBits_, _position_, _radius_, _falloff_, _impulsePerLength_)
      instance = ExplosionDef.new
      instance[:maskBits] = _maskBits_
      instance[:position] = _position_
      instance[:radius] = _radius_
      instance[:falloff] = _falloff_
      instance[:impulsePerLength] = _impulsePerLength_
      instance
    end
  end

  class SensorBeginTouchEvent < FFI::Struct
    layout(
      :sensorShapeId, ShapeId,
      :visitorShapeId, ShapeId,
    )
    def sensorShapeId = self[:sensorShapeId]
    def sensorShapeId=(v) self[:sensorShapeId] = v end
    def visitorShapeId = self[:visitorShapeId]
    def visitorShapeId=(v) self[:visitorShapeId] = v end
    def self.create_as(_sensorShapeId_, _visitorShapeId_)
      instance = SensorBeginTouchEvent.new
      instance[:sensorShapeId] = _sensorShapeId_
      instance[:visitorShapeId] = _visitorShapeId_
      instance
    end
  end

  class SensorEndTouchEvent < FFI::Struct
    layout(
      :sensorShapeId, ShapeId,
      :visitorShapeId, ShapeId,
    )
    def sensorShapeId = self[:sensorShapeId]
    def sensorShapeId=(v) self[:sensorShapeId] = v end
    def visitorShapeId = self[:visitorShapeId]
    def visitorShapeId=(v) self[:visitorShapeId] = v end
    def self.create_as(_sensorShapeId_, _visitorShapeId_)
      instance = SensorEndTouchEvent.new
      instance[:sensorShapeId] = _sensorShapeId_
      instance[:visitorShapeId] = _visitorShapeId_
      instance
    end
  end

  class SensorEvents < FFI::Struct
    layout(
      :beginEvents, :pointer,
      :endEvents, :pointer,
      :beginCount, :int,
      :endCount, :int,
    )
    def beginEvents = self[:beginEvents]
    def beginEvents=(v) self[:beginEvents] = v end
    def endEvents = self[:endEvents]
    def endEvents=(v) self[:endEvents] = v end
    def beginCount = self[:beginCount]
    def beginCount=(v) self[:beginCount] = v end
    def endCount = self[:endCount]
    def endCount=(v) self[:endCount] = v end
    def self.create_as(_beginEvents_, _endEvents_, _beginCount_, _endCount_)
      instance = SensorEvents.new
      instance[:beginEvents] = _beginEvents_
      instance[:endEvents] = _endEvents_
      instance[:beginCount] = _beginCount_
      instance[:endCount] = _endCount_
      instance
    end
  end

  class ContactBeginTouchEvent < FFI::Struct
    layout(
      :shapeIdA, ShapeId,
      :shapeIdB, ShapeId,
      :manifold, Manifold,
    )
    def shapeIdA = self[:shapeIdA]
    def shapeIdA=(v) self[:shapeIdA] = v end
    def shapeIdB = self[:shapeIdB]
    def shapeIdB=(v) self[:shapeIdB] = v end
    def manifold = self[:manifold]
    def manifold=(v) self[:manifold] = v end
    def self.create_as(_shapeIdA_, _shapeIdB_, _manifold_)
      instance = ContactBeginTouchEvent.new
      instance[:shapeIdA] = _shapeIdA_
      instance[:shapeIdB] = _shapeIdB_
      instance[:manifold] = _manifold_
      instance
    end
  end

  class ContactEndTouchEvent < FFI::Struct
    layout(
      :shapeIdA, ShapeId,
      :shapeIdB, ShapeId,
    )
    def shapeIdA = self[:shapeIdA]
    def shapeIdA=(v) self[:shapeIdA] = v end
    def shapeIdB = self[:shapeIdB]
    def shapeIdB=(v) self[:shapeIdB] = v end
    def self.create_as(_shapeIdA_, _shapeIdB_)
      instance = ContactEndTouchEvent.new
      instance[:shapeIdA] = _shapeIdA_
      instance[:shapeIdB] = _shapeIdB_
      instance
    end
  end

  class ContactHitEvent < FFI::Struct
    layout(
      :shapeIdA, ShapeId,
      :shapeIdB, ShapeId,
      :point, Vec2,
      :normal, Vec2,
      :approachSpeed, :float,
    )
    def shapeIdA = self[:shapeIdA]
    def shapeIdA=(v) self[:shapeIdA] = v end
    def shapeIdB = self[:shapeIdB]
    def shapeIdB=(v) self[:shapeIdB] = v end
    def point = self[:point]
    def point=(v) self[:point] = v end
    def normal = self[:normal]
    def normal=(v) self[:normal] = v end
    def approachSpeed = self[:approachSpeed]
    def approachSpeed=(v) self[:approachSpeed] = v end
    def self.create_as(_shapeIdA_, _shapeIdB_, _point_, _normal_, _approachSpeed_)
      instance = ContactHitEvent.new
      instance[:shapeIdA] = _shapeIdA_
      instance[:shapeIdB] = _shapeIdB_
      instance[:point] = _point_
      instance[:normal] = _normal_
      instance[:approachSpeed] = _approachSpeed_
      instance
    end
  end

  class ContactEvents < FFI::Struct
    layout(
      :beginEvents, :pointer,
      :endEvents, :pointer,
      :hitEvents, :pointer,
      :beginCount, :int,
      :endCount, :int,
      :hitCount, :int,
    )
    def beginEvents = self[:beginEvents]
    def beginEvents=(v) self[:beginEvents] = v end
    def endEvents = self[:endEvents]
    def endEvents=(v) self[:endEvents] = v end
    def hitEvents = self[:hitEvents]
    def hitEvents=(v) self[:hitEvents] = v end
    def beginCount = self[:beginCount]
    def beginCount=(v) self[:beginCount] = v end
    def endCount = self[:endCount]
    def endCount=(v) self[:endCount] = v end
    def hitCount = self[:hitCount]
    def hitCount=(v) self[:hitCount] = v end
    def self.create_as(_beginEvents_, _endEvents_, _hitEvents_, _beginCount_, _endCount_, _hitCount_)
      instance = ContactEvents.new
      instance[:beginEvents] = _beginEvents_
      instance[:endEvents] = _endEvents_
      instance[:hitEvents] = _hitEvents_
      instance[:beginCount] = _beginCount_
      instance[:endCount] = _endCount_
      instance[:hitCount] = _hitCount_
      instance
    end
  end

  class BodyMoveEvent < FFI::Struct
    layout(
      :transform, Transform,
      :bodyId, BodyId,
      :userData, :pointer,
      :fellAsleep, :bool,
    )
    def transform = self[:transform]
    def transform=(v) self[:transform] = v end
    def bodyId = self[:bodyId]
    def bodyId=(v) self[:bodyId] = v end
    def userData = self[:userData]
    def userData=(v) self[:userData] = v end
    def fellAsleep = self[:fellAsleep]
    def fellAsleep=(v) self[:fellAsleep] = v end
    def self.create_as(_transform_, _bodyId_, _userData_, _fellAsleep_)
      instance = BodyMoveEvent.new
      instance[:transform] = _transform_
      instance[:bodyId] = _bodyId_
      instance[:userData] = _userData_
      instance[:fellAsleep] = _fellAsleep_
      instance
    end
  end

  class BodyEvents < FFI::Struct
    layout(
      :moveEvents, :pointer,
      :moveCount, :int,
    )
    def moveEvents = self[:moveEvents]
    def moveEvents=(v) self[:moveEvents] = v end
    def moveCount = self[:moveCount]
    def moveCount=(v) self[:moveCount] = v end
    def self.create_as(_moveEvents_, _moveCount_)
      instance = BodyEvents.new
      instance[:moveEvents] = _moveEvents_
      instance[:moveCount] = _moveCount_
      instance
    end
  end

  class ContactData < FFI::Struct
    layout(
      :shapeIdA, ShapeId,
      :shapeIdB, ShapeId,
      :manifold, Manifold,
    )
    def shapeIdA = self[:shapeIdA]
    def shapeIdA=(v) self[:shapeIdA] = v end
    def shapeIdB = self[:shapeIdB]
    def shapeIdB=(v) self[:shapeIdB] = v end
    def manifold = self[:manifold]
    def manifold=(v) self[:manifold] = v end
    def self.create_as(_shapeIdA_, _shapeIdB_, _manifold_)
      instance = ContactData.new
      instance[:shapeIdA] = _shapeIdA_
      instance[:shapeIdB] = _shapeIdB_
      instance[:manifold] = _manifold_
      instance
    end
  end

  class DebugDraw < FFI::Struct
    layout(
      :DrawPolygon, :pointer,
      :DrawSolidPolygon, :pointer,
      :DrawCircle, :pointer,
      :DrawSolidCircle, :pointer,
      :DrawSolidCapsule, :pointer,
      :DrawSegment, :pointer,
      :DrawTransform, :pointer,
      :DrawPoint, :pointer,
      :DrawString, :pointer,
      :drawingBounds, AABB,
      :useDrawingBounds, :bool,
      :drawShapes, :bool,
      :drawJoints, :bool,
      :drawJointExtras, :bool,
      :drawAABBs, :bool,
      :drawMass, :bool,
      :drawBodyNames, :bool,
      :drawContacts, :bool,
      :drawGraphColors, :bool,
      :drawContactNormals, :bool,
      :drawContactImpulses, :bool,
      :drawFrictionImpulses, :bool,
      :context, :pointer,
    )
    def DrawPolygon = self[:DrawPolygon]
    def DrawPolygon=(v) self[:DrawPolygon] = v end
    def DrawSolidPolygon = self[:DrawSolidPolygon]
    def DrawSolidPolygon=(v) self[:DrawSolidPolygon] = v end
    def DrawCircle = self[:DrawCircle]
    def DrawCircle=(v) self[:DrawCircle] = v end
    def DrawSolidCircle = self[:DrawSolidCircle]
    def DrawSolidCircle=(v) self[:DrawSolidCircle] = v end
    def DrawSolidCapsule = self[:DrawSolidCapsule]
    def DrawSolidCapsule=(v) self[:DrawSolidCapsule] = v end
    def DrawSegment = self[:DrawSegment]
    def DrawSegment=(v) self[:DrawSegment] = v end
    def DrawTransform = self[:DrawTransform]
    def DrawTransform=(v) self[:DrawTransform] = v end
    def DrawPoint = self[:DrawPoint]
    def DrawPoint=(v) self[:DrawPoint] = v end
    def DrawString = self[:DrawString]
    def DrawString=(v) self[:DrawString] = v end
    def drawingBounds = self[:drawingBounds]
    def drawingBounds=(v) self[:drawingBounds] = v end
    def useDrawingBounds = self[:useDrawingBounds]
    def useDrawingBounds=(v) self[:useDrawingBounds] = v end
    def drawShapes = self[:drawShapes]
    def drawShapes=(v) self[:drawShapes] = v end
    def drawJoints = self[:drawJoints]
    def drawJoints=(v) self[:drawJoints] = v end
    def drawJointExtras = self[:drawJointExtras]
    def drawJointExtras=(v) self[:drawJointExtras] = v end
    def drawAABBs = self[:drawAABBs]
    def drawAABBs=(v) self[:drawAABBs] = v end
    def drawMass = self[:drawMass]
    def drawMass=(v) self[:drawMass] = v end
    def drawBodyNames = self[:drawBodyNames]
    def drawBodyNames=(v) self[:drawBodyNames] = v end
    def drawContacts = self[:drawContacts]
    def drawContacts=(v) self[:drawContacts] = v end
    def drawGraphColors = self[:drawGraphColors]
    def drawGraphColors=(v) self[:drawGraphColors] = v end
    def drawContactNormals = self[:drawContactNormals]
    def drawContactNormals=(v) self[:drawContactNormals] = v end
    def drawContactImpulses = self[:drawContactImpulses]
    def drawContactImpulses=(v) self[:drawContactImpulses] = v end
    def drawFrictionImpulses = self[:drawFrictionImpulses]
    def drawFrictionImpulses=(v) self[:drawFrictionImpulses] = v end
    def context = self[:context]
    def context=(v) self[:context] = v end
    def self.create_as(_DrawPolygon_, _DrawSolidPolygon_, _DrawCircle_, _DrawSolidCircle_, _DrawSolidCapsule_, _DrawSegment_, _DrawTransform_, _DrawPoint_, _DrawString_, _drawingBounds_, _useDrawingBounds_, _drawShapes_, _drawJoints_, _drawJointExtras_, _drawAABBs_, _drawMass_, _drawBodyNames_, _drawContacts_, _drawGraphColors_, _drawContactNormals_, _drawContactImpulses_, _drawFrictionImpulses_, _context_)
      instance = DebugDraw.new
      instance[:DrawPolygon] = _DrawPolygon_
      instance[:DrawSolidPolygon] = _DrawSolidPolygon_
      instance[:DrawCircle] = _DrawCircle_
      instance[:DrawSolidCircle] = _DrawSolidCircle_
      instance[:DrawSolidCapsule] = _DrawSolidCapsule_
      instance[:DrawSegment] = _DrawSegment_
      instance[:DrawTransform] = _DrawTransform_
      instance[:DrawPoint] = _DrawPoint_
      instance[:DrawString] = _DrawString_
      instance[:drawingBounds] = _drawingBounds_
      instance[:useDrawingBounds] = _useDrawingBounds_
      instance[:drawShapes] = _drawShapes_
      instance[:drawJoints] = _drawJoints_
      instance[:drawJointExtras] = _drawJointExtras_
      instance[:drawAABBs] = _drawAABBs_
      instance[:drawMass] = _drawMass_
      instance[:drawBodyNames] = _drawBodyNames_
      instance[:drawContacts] = _drawContacts_
      instance[:drawGraphColors] = _drawGraphColors_
      instance[:drawContactNormals] = _drawContactNormals_
      instance[:drawContactImpulses] = _drawContactImpulses_
      instance[:drawFrictionImpulses] = _drawFrictionImpulses_
      instance[:context] = _context_
      instance
    end
  end


  # Function

  def self.setup_types_symbols(method_naming: :original)
    entries = [
      [:DefaultWorldDef, :b2DefaultWorldDef, [], WorldDef.by_value],
      [:DefaultBodyDef, :b2DefaultBodyDef, [], BodyDef.by_value],
      [:DefaultFilter, :b2DefaultFilter, [], Filter.by_value],
      [:DefaultQueryFilter, :b2DefaultQueryFilter, [], QueryFilter.by_value],
      [:DefaultShapeDef, :b2DefaultShapeDef, [], ShapeDef.by_value],
      [:DefaultSurfaceMaterial, :b2DefaultSurfaceMaterial, [], SurfaceMaterial.by_value],
      [:DefaultChainDef, :b2DefaultChainDef, [], ChainDef.by_value],
      [:DefaultDistanceJointDef, :b2DefaultDistanceJointDef, [], DistanceJointDef.by_value],
      [:DefaultMotorJointDef, :b2DefaultMotorJointDef, [], MotorJointDef.by_value],
      [:DefaultMouseJointDef, :b2DefaultMouseJointDef, [], MouseJointDef.by_value],
      [:DefaultNullJointDef, :b2DefaultNullJointDef, [], NullJointDef.by_value],
      [:DefaultPrismaticJointDef, :b2DefaultPrismaticJointDef, [], PrismaticJointDef.by_value],
      [:DefaultRevoluteJointDef, :b2DefaultRevoluteJointDef, [], RevoluteJointDef.by_value],
      [:DefaultWeldJointDef, :b2DefaultWeldJointDef, [], WeldJointDef.by_value],
      [:DefaultWheelJointDef, :b2DefaultWheelJointDef, [], WheelJointDef.by_value],
      [:DefaultExplosionDef, :b2DefaultExplosionDef, [], ExplosionDef.by_value],
      [:DefaultDebugDraw, :b2DefaultDebugDraw, [], DebugDraw.by_value],
    ]
    entries.each do |entry|
      api_name = if method_naming == :snake_case
                   snake_case_name = entry[0].to_s.gsub(/([A-Z]+)([A-Z0-9][a-z])/, '\1_\2').gsub(/([a-z\d])([A-Z0-9])/, '\1_\2').downcase
                   snake_case_name.gsub!('vector_3', 'vector3_') if snake_case_name.include?('vector_3')
                   snake_case_name.gsub!('vector_2', 'vector2_') if snake_case_name.include?('vector_2')
                   snake_case_name.chop! if snake_case_name.end_with?('_')
                   snake_case_name.to_sym
                 else
                   entry[0]
                 end
      attach_function api_name, entry[1], entry[2], entry[3]
    rescue FFI::NotFoundError => e
      warn "[Warning] Failed to import #{entry[0]} (#{e})."
    end
  end

end

