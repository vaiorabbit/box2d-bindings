# Ruby-Box2D : Yet another Box2D wrapper for Ruby
#
# * https://github.com/vaiorabbit/box2d-bindings
#
# [NOTICE] Autogenerated. Do not edit.

require 'ffi'

module Box2D
  extend FFI::Library
  # Define/Macro

  MAX_POLYGON_VERTICES = 8

  # Enum

  TOIState_toiStateUnknown = 0
  TOIState_toiStateFailed = 1
  TOIState_toiStateOverlapped = 2
  TOIState_toiStateHit = 3
  TOIState_toiStateSeparated = 4

  # Typedef

  typedef :int, :b2TOIState
  typedef :pointer, :b2TreeQueryCallbackFcn
  typedef :pointer, :b2TreeRayCastCallbackFcn
  typedef :pointer, :b2TreeShapeCastCallbackFcn

  # Struct


  class TreeNode_Union < FFI::Union
    layout(
      :parent, :int,
      :next, :int,
    )
  end

  class TreeNode < FFI::Struct
    layout(
      :aabb, AABB,
      :categoryBits, :uint,
      :union, TreeNode_Union,
      :child1, :int,
      :child2, :int,
      :userData, :int,
      :height, :short,
      :enlarged, :int,
      :pad, [:char, 9],
    )
    def aabb = self[:aabb]
    def aabb=(v) self[:aabb] = v end
    def categoryBits = self[:categoryBits]
    def categoryBits=(v) self[:categoryBits] = v end
    def union = self[:union]
    def union=(v) self[:union] = v end
    def child1 = self[:child1]
    def child1=(v) self[:child1] = v end
    def child2 = self[:child2]
    def child2=(v) self[:child2] = v end
    def userData = self[:userData]
    def userData=(v) self[:userData] = v end
    def height = self[:height]
    def height=(v) self[:height] = v end
    def enlarged = self[:enlarged]
    def enlarged=(v) self[:enlarged] = v end
    def pad = self[:pad]
    def pad=(v) self[:pad] = v end
    def self.create_as(_aabb_, _categoryBits_, _union_, _child1_, _child2_, _userData_, _height_, _enlarged_, _pad_)
      instance = b2TreeNode.new
      instance[:aabb] = _aabb_
      instance[:categoryBits] = _categoryBits_
      instance[:union] = _union_
      instance[:child1] = _child1_
      instance[:child2] = _child2_
      instance[:userData] = _userData_
      instance[:height] = _height_
      instance[:enlarged] = _enlarged_
      instance[:pad] = _pad_
      instance
    end
  end

  class SimplexCache < FFI::Struct
    layout(
      :count, :ushort,
      :indexA, [:uchar, 3],
      :indexB, [:uchar, 3],
    )
    def count = self[:count]
    def count=(v) self[:count] = v end
    def indexA = self[:indexA]
    def indexA=(v) self[:indexA] = v end
    def indexB = self[:indexB]
    def indexB=(v) self[:indexB] = v end
    def self.create_as(_count_, _indexA_, _indexB_)
      instance = SimplexCache.new
      instance[:count] = _count_
      instance[:indexA] = _indexA_
      instance[:indexB] = _indexB_
      instance
    end
  end

  class Hull < FFI::Struct
    layout(
      :points, [Vec2, 8],
      :count, :int,
    )
    def points = self[:points]
    def points=(v) self[:points] = v end
    def count = self[:count]
    def count=(v) self[:count] = v end
    def self.create_as(_points_, _count_)
      instance = Hull.new
      instance[:points] = _points_
      instance[:count] = _count_
      instance
    end
  end

  class RayCastInput < FFI::Struct
    layout(
      :origin, Vec2,
      :translation, Vec2,
      :maxFraction, :float,
    )
    def origin = self[:origin]
    def origin=(v) self[:origin] = v end
    def translation = self[:translation]
    def translation=(v) self[:translation] = v end
    def maxFraction = self[:maxFraction]
    def maxFraction=(v) self[:maxFraction] = v end
    def self.create_as(_origin_, _translation_, _maxFraction_)
      instance = RayCastInput.new
      instance[:origin] = _origin_
      instance[:translation] = _translation_
      instance[:maxFraction] = _maxFraction_
      instance
    end
  end

  class ShapeCastInput < FFI::Struct
    layout(
      :points, [Vec2, 8],
      :count, :int,
      :radius, :float,
      :translation, Vec2,
      :maxFraction, :float,
    )
    def points = self[:points]
    def points=(v) self[:points] = v end
    def count = self[:count]
    def count=(v) self[:count] = v end
    def radius = self[:radius]
    def radius=(v) self[:radius] = v end
    def translation = self[:translation]
    def translation=(v) self[:translation] = v end
    def maxFraction = self[:maxFraction]
    def maxFraction=(v) self[:maxFraction] = v end
    def self.create_as(_points_, _count_, _radius_, _translation_, _maxFraction_)
      instance = ShapeCastInput.new
      instance[:points] = _points_
      instance[:count] = _count_
      instance[:radius] = _radius_
      instance[:translation] = _translation_
      instance[:maxFraction] = _maxFraction_
      instance
    end
  end

  class CastOutput < FFI::Struct
    layout(
      :normal, Vec2,
      :point, Vec2,
      :fraction, :float,
      :iterations, :int,
      :hit, :bool,
    )
    def normal = self[:normal]
    def normal=(v) self[:normal] = v end
    def point = self[:point]
    def point=(v) self[:point] = v end
    def fraction = self[:fraction]
    def fraction=(v) self[:fraction] = v end
    def iterations = self[:iterations]
    def iterations=(v) self[:iterations] = v end
    def hit = self[:hit]
    def hit=(v) self[:hit] = v end
    def self.create_as(_normal_, _point_, _fraction_, _iterations_, _hit_)
      instance = CastOutput.new
      instance[:normal] = _normal_
      instance[:point] = _point_
      instance[:fraction] = _fraction_
      instance[:iterations] = _iterations_
      instance[:hit] = _hit_
      instance
    end
  end

  class MassData < FFI::Struct
    layout(
      :mass, :float,
      :center, Vec2,
      :rotationalInertia, :float,
    )
    def mass = self[:mass]
    def mass=(v) self[:mass] = v end
    def center = self[:center]
    def center=(v) self[:center] = v end
    def rotationalInertia = self[:rotationalInertia]
    def rotationalInertia=(v) self[:rotationalInertia] = v end
    def self.create_as(_mass_, _center_, _rotationalInertia_)
      instance = MassData.new
      instance[:mass] = _mass_
      instance[:center] = _center_
      instance[:rotationalInertia] = _rotationalInertia_
      instance
    end
  end

  class Circle < FFI::Struct
    layout(
      :center, Vec2,
      :radius, :float,
    )
    def center = self[:center]
    def center=(v) self[:center] = v end
    def radius = self[:radius]
    def radius=(v) self[:radius] = v end
    def self.create_as(_center_, _radius_)
      instance = Circle.new
      instance[:center] = _center_
      instance[:radius] = _radius_
      instance
    end
  end

  class Capsule < FFI::Struct
    layout(
      :center1, Vec2,
      :center2, Vec2,
      :radius, :float,
    )
    def center1 = self[:center1]
    def center1=(v) self[:center1] = v end
    def center2 = self[:center2]
    def center2=(v) self[:center2] = v end
    def radius = self[:radius]
    def radius=(v) self[:radius] = v end
    def self.create_as(_center1_, _center2_, _radius_)
      instance = Capsule.new
      instance[:center1] = _center1_
      instance[:center2] = _center2_
      instance[:radius] = _radius_
      instance
    end
  end

  class Polygon < FFI::Struct
    layout(
      :vertices, [Vec2, 8],
      :normals, [Vec2, 8],
      :centroid, Vec2,
      :radius, :float,
      :count, :int,
    )
    def vertices = self[:vertices]
    def vertices=(v) self[:vertices] = v end
    def normals = self[:normals]
    def normals=(v) self[:normals] = v end
    def centroid = self[:centroid]
    def centroid=(v) self[:centroid] = v end
    def radius = self[:radius]
    def radius=(v) self[:radius] = v end
    def count = self[:count]
    def count=(v) self[:count] = v end
    def self.create_as(_vertices_, _normals_, _centroid_, _radius_, _count_)
      instance = Polygon.new
      instance[:vertices] = _vertices_
      instance[:normals] = _normals_
      instance[:centroid] = _centroid_
      instance[:radius] = _radius_
      instance[:count] = _count_
      instance
    end
  end

  class Segment < FFI::Struct
    layout(
      :point1, Vec2,
      :point2, Vec2,
    )
    def point1 = self[:point1]
    def point1=(v) self[:point1] = v end
    def point2 = self[:point2]
    def point2=(v) self[:point2] = v end
    def self.create_as(_point1_, _point2_)
      instance = Segment.new
      instance[:point1] = _point1_
      instance[:point2] = _point2_
      instance
    end
  end

  class ChainSegment < FFI::Struct
    layout(
      :ghost1, Vec2,
      :segment, Segment,
      :ghost2, Vec2,
      :chainId, :int,
    )
    def ghost1 = self[:ghost1]
    def ghost1=(v) self[:ghost1] = v end
    def segment = self[:segment]
    def segment=(v) self[:segment] = v end
    def ghost2 = self[:ghost2]
    def ghost2=(v) self[:ghost2] = v end
    def chainId = self[:chainId]
    def chainId=(v) self[:chainId] = v end
    def self.create_as(_ghost1_, _segment_, _ghost2_, _chainId_)
      instance = ChainSegment.new
      instance[:ghost1] = _ghost1_
      instance[:segment] = _segment_
      instance[:ghost2] = _ghost2_
      instance[:chainId] = _chainId_
      instance
    end
  end

  class SegmentDistanceResult < FFI::Struct
    layout(
      :closest1, Vec2,
      :closest2, Vec2,
      :fraction1, :float,
      :fraction2, :float,
      :distanceSquared, :float,
    )
    def closest1 = self[:closest1]
    def closest1=(v) self[:closest1] = v end
    def closest2 = self[:closest2]
    def closest2=(v) self[:closest2] = v end
    def fraction1 = self[:fraction1]
    def fraction1=(v) self[:fraction1] = v end
    def fraction2 = self[:fraction2]
    def fraction2=(v) self[:fraction2] = v end
    def distanceSquared = self[:distanceSquared]
    def distanceSquared=(v) self[:distanceSquared] = v end
    def self.create_as(_closest1_, _closest2_, _fraction1_, _fraction2_, _distanceSquared_)
      instance = SegmentDistanceResult.new
      instance[:closest1] = _closest1_
      instance[:closest2] = _closest2_
      instance[:fraction1] = _fraction1_
      instance[:fraction2] = _fraction2_
      instance[:distanceSquared] = _distanceSquared_
      instance
    end
  end

  class ShapeProxy < FFI::Struct
    layout(
      :points, [Vec2, 8],
      :count, :int,
      :radius, :float,
    )
    def points = self[:points]
    def points=(v) self[:points] = v end
    def count = self[:count]
    def count=(v) self[:count] = v end
    def radius = self[:radius]
    def radius=(v) self[:radius] = v end
    def self.create_as(_points_, _count_, _radius_)
      instance = ShapeProxy.new
      instance[:points] = _points_
      instance[:count] = _count_
      instance[:radius] = _radius_
      instance
    end
  end

  class DistanceInput < FFI::Struct
    layout(
      :proxyA, ShapeProxy,
      :proxyB, ShapeProxy,
      :transformA, Transform,
      :transformB, Transform,
      :useRadii, :bool,
    )
    def proxyA = self[:proxyA]
    def proxyA=(v) self[:proxyA] = v end
    def proxyB = self[:proxyB]
    def proxyB=(v) self[:proxyB] = v end
    def transformA = self[:transformA]
    def transformA=(v) self[:transformA] = v end
    def transformB = self[:transformB]
    def transformB=(v) self[:transformB] = v end
    def useRadii = self[:useRadii]
    def useRadii=(v) self[:useRadii] = v end
    def self.create_as(_proxyA_, _proxyB_, _transformA_, _transformB_, _useRadii_)
      instance = DistanceInput.new
      instance[:proxyA] = _proxyA_
      instance[:proxyB] = _proxyB_
      instance[:transformA] = _transformA_
      instance[:transformB] = _transformB_
      instance[:useRadii] = _useRadii_
      instance
    end
  end

  class DistanceOutput < FFI::Struct
    layout(
      :pointA, Vec2,
      :pointB, Vec2,
      :distance, :float,
      :iterations, :int,
      :simplexCount, :int,
    )
    def pointA = self[:pointA]
    def pointA=(v) self[:pointA] = v end
    def pointB = self[:pointB]
    def pointB=(v) self[:pointB] = v end
    def distance = self[:distance]
    def distance=(v) self[:distance] = v end
    def iterations = self[:iterations]
    def iterations=(v) self[:iterations] = v end
    def simplexCount = self[:simplexCount]
    def simplexCount=(v) self[:simplexCount] = v end
    def self.create_as(_pointA_, _pointB_, _distance_, _iterations_, _simplexCount_)
      instance = DistanceOutput.new
      instance[:pointA] = _pointA_
      instance[:pointB] = _pointB_
      instance[:distance] = _distance_
      instance[:iterations] = _iterations_
      instance[:simplexCount] = _simplexCount_
      instance
    end
  end

  class SimplexVertex < FFI::Struct
    layout(
      :wA, Vec2,
      :wB, Vec2,
      :w, Vec2,
      :a, :float,
      :indexA, :int,
      :indexB, :int,
    )
    def wA = self[:wA]
    def wA=(v) self[:wA] = v end
    def wB = self[:wB]
    def wB=(v) self[:wB] = v end
    def w = self[:w]
    def w=(v) self[:w] = v end
    def a = self[:a]
    def a=(v) self[:a] = v end
    def indexA = self[:indexA]
    def indexA=(v) self[:indexA] = v end
    def indexB = self[:indexB]
    def indexB=(v) self[:indexB] = v end
    def self.create_as(_wA_, _wB_, _w_, _a_, _indexA_, _indexB_)
      instance = SimplexVertex.new
      instance[:wA] = _wA_
      instance[:wB] = _wB_
      instance[:w] = _w_
      instance[:a] = _a_
      instance[:indexA] = _indexA_
      instance[:indexB] = _indexB_
      instance
    end
  end

  class Simplex < FFI::Struct
    layout(
      :v1, SimplexVertex,
      :v2, SimplexVertex,
      :v3, SimplexVertex,
      :count, :int,
    )
    def v1 = self[:v1]
    def v1=(v) self[:v1] = v end
    def v2 = self[:v2]
    def v2=(v) self[:v2] = v end
    def v3 = self[:v3]
    def v3=(v) self[:v3] = v end
    def count = self[:count]
    def count=(v) self[:count] = v end
    def self.create_as(_v1_, _v2_, _v3_, _count_)
      instance = Simplex.new
      instance[:v1] = _v1_
      instance[:v2] = _v2_
      instance[:v3] = _v3_
      instance[:count] = _count_
      instance
    end
  end

  class ShapeCastPairInput < FFI::Struct
    layout(
      :proxyA, ShapeProxy,
      :proxyB, ShapeProxy,
      :transformA, Transform,
      :transformB, Transform,
      :translationB, Vec2,
      :maxFraction, :float,
    )
    def proxyA = self[:proxyA]
    def proxyA=(v) self[:proxyA] = v end
    def proxyB = self[:proxyB]
    def proxyB=(v) self[:proxyB] = v end
    def transformA = self[:transformA]
    def transformA=(v) self[:transformA] = v end
    def transformB = self[:transformB]
    def transformB=(v) self[:transformB] = v end
    def translationB = self[:translationB]
    def translationB=(v) self[:translationB] = v end
    def maxFraction = self[:maxFraction]
    def maxFraction=(v) self[:maxFraction] = v end
    def self.create_as(_proxyA_, _proxyB_, _transformA_, _transformB_, _translationB_, _maxFraction_)
      instance = ShapeCastPairInput.new
      instance[:proxyA] = _proxyA_
      instance[:proxyB] = _proxyB_
      instance[:transformA] = _transformA_
      instance[:transformB] = _transformB_
      instance[:translationB] = _translationB_
      instance[:maxFraction] = _maxFraction_
      instance
    end
  end

  class Sweep < FFI::Struct
    layout(
      :localCenter, Vec2,
      :c1, Vec2,
      :c2, Vec2,
      :q1, Rot,
      :q2, Rot,
    )
    def localCenter = self[:localCenter]
    def localCenter=(v) self[:localCenter] = v end
    def c1 = self[:c1]
    def c1=(v) self[:c1] = v end
    def c2 = self[:c2]
    def c2=(v) self[:c2] = v end
    def q1 = self[:q1]
    def q1=(v) self[:q1] = v end
    def q2 = self[:q2]
    def q2=(v) self[:q2] = v end
    def self.create_as(_localCenter_, _c1_, _c2_, _q1_, _q2_)
      instance = Sweep.new
      instance[:localCenter] = _localCenter_
      instance[:c1] = _c1_
      instance[:c2] = _c2_
      instance[:q1] = _q1_
      instance[:q2] = _q2_
      instance
    end
  end

  class TOIInput < FFI::Struct
    layout(
      :proxyA, ShapeProxy,
      :proxyB, ShapeProxy,
      :sweepA, Sweep,
      :sweepB, Sweep,
      :maxFraction, :float,
    )
    def proxyA = self[:proxyA]
    def proxyA=(v) self[:proxyA] = v end
    def proxyB = self[:proxyB]
    def proxyB=(v) self[:proxyB] = v end
    def sweepA = self[:sweepA]
    def sweepA=(v) self[:sweepA] = v end
    def sweepB = self[:sweepB]
    def sweepB=(v) self[:sweepB] = v end
    def maxFraction = self[:maxFraction]
    def maxFraction=(v) self[:maxFraction] = v end
    def self.create_as(_proxyA_, _proxyB_, _sweepA_, _sweepB_, _maxFraction_)
      instance = TOIInput.new
      instance[:proxyA] = _proxyA_
      instance[:proxyB] = _proxyB_
      instance[:sweepA] = _sweepA_
      instance[:sweepB] = _sweepB_
      instance[:maxFraction] = _maxFraction_
      instance
    end
  end

  class TOIOutput < FFI::Struct
    layout(
      :state, :int,
      :fraction, :float,
    )
    def state = self[:state]
    def state=(v) self[:state] = v end
    def fraction = self[:fraction]
    def fraction=(v) self[:fraction] = v end
    def self.create_as(_state_, _fraction_)
      instance = TOIOutput.new
      instance[:state] = _state_
      instance[:fraction] = _fraction_
      instance
    end
  end

  class ManifoldPoint < FFI::Struct
    layout(
      :point, Vec2,
      :anchorA, Vec2,
      :anchorB, Vec2,
      :separation, :float,
      :normalImpulse, :float,
      :tangentImpulse, :float,
      :maxNormalImpulse, :float,
      :normalVelocity, :float,
      :id, :ushort,
      :persisted, :bool,
    )
    def point = self[:point]
    def point=(v) self[:point] = v end
    def anchorA = self[:anchorA]
    def anchorA=(v) self[:anchorA] = v end
    def anchorB = self[:anchorB]
    def anchorB=(v) self[:anchorB] = v end
    def separation = self[:separation]
    def separation=(v) self[:separation] = v end
    def normalImpulse = self[:normalImpulse]
    def normalImpulse=(v) self[:normalImpulse] = v end
    def tangentImpulse = self[:tangentImpulse]
    def tangentImpulse=(v) self[:tangentImpulse] = v end
    def maxNormalImpulse = self[:maxNormalImpulse]
    def maxNormalImpulse=(v) self[:maxNormalImpulse] = v end
    def normalVelocity = self[:normalVelocity]
    def normalVelocity=(v) self[:normalVelocity] = v end
    def id = self[:id]
    def id=(v) self[:id] = v end
    def persisted = self[:persisted]
    def persisted=(v) self[:persisted] = v end
    def self.create_as(_point_, _anchorA_, _anchorB_, _separation_, _normalImpulse_, _tangentImpulse_, _maxNormalImpulse_, _normalVelocity_, _id_, _persisted_)
      instance = ManifoldPoint.new
      instance[:point] = _point_
      instance[:anchorA] = _anchorA_
      instance[:anchorB] = _anchorB_
      instance[:separation] = _separation_
      instance[:normalImpulse] = _normalImpulse_
      instance[:tangentImpulse] = _tangentImpulse_
      instance[:maxNormalImpulse] = _maxNormalImpulse_
      instance[:normalVelocity] = _normalVelocity_
      instance[:id] = _id_
      instance[:persisted] = _persisted_
      instance
    end
  end

  class Manifold < FFI::Struct
    layout(
      :points, [ManifoldPoint, 2],
      :normal, Vec2,
      :pointCount, :int,
    )
    def points = self[:points]
    def points=(v) self[:points] = v end
    def normal = self[:normal]
    def normal=(v) self[:normal] = v end
    def pointCount = self[:pointCount]
    def pointCount=(v) self[:pointCount] = v end
    def self.create_as(_points_, _normal_, _pointCount_)
      instance = Manifold.new
      instance[:points] = _points_
      instance[:normal] = _normal_
      instance[:pointCount] = _pointCount_
      instance
    end
  end

  class DynamicTree < FFI::Struct
    layout(
      :nodes, :pointer,
      :root, :int,
      :nodeCount, :int,
      :nodeCapacity, :int,
      :freeList, :int,
      :proxyCount, :int,
      :leafIndices, :pointer,
      :leafBoxes, :pointer,
      :leafCenters, :pointer,
      :binIndices, :pointer,
      :rebuildCapacity, :int,
    )
    def nodes = self[:nodes]
    def nodes=(v) self[:nodes] = v end
    def root = self[:root]
    def root=(v) self[:root] = v end
    def nodeCount = self[:nodeCount]
    def nodeCount=(v) self[:nodeCount] = v end
    def nodeCapacity = self[:nodeCapacity]
    def nodeCapacity=(v) self[:nodeCapacity] = v end
    def freeList = self[:freeList]
    def freeList=(v) self[:freeList] = v end
    def proxyCount = self[:proxyCount]
    def proxyCount=(v) self[:proxyCount] = v end
    def leafIndices = self[:leafIndices]
    def leafIndices=(v) self[:leafIndices] = v end
    def leafBoxes = self[:leafBoxes]
    def leafBoxes=(v) self[:leafBoxes] = v end
    def leafCenters = self[:leafCenters]
    def leafCenters=(v) self[:leafCenters] = v end
    def binIndices = self[:binIndices]
    def binIndices=(v) self[:binIndices] = v end
    def rebuildCapacity = self[:rebuildCapacity]
    def rebuildCapacity=(v) self[:rebuildCapacity] = v end
    def self.create_as(_nodes_, _root_, _nodeCount_, _nodeCapacity_, _freeList_, _proxyCount_, _leafIndices_, _leafBoxes_, _leafCenters_, _binIndices_, _rebuildCapacity_)
      instance = DynamicTree.new
      instance[:nodes] = _nodes_
      instance[:root] = _root_
      instance[:nodeCount] = _nodeCount_
      instance[:nodeCapacity] = _nodeCapacity_
      instance[:freeList] = _freeList_
      instance[:proxyCount] = _proxyCount_
      instance[:leafIndices] = _leafIndices_
      instance[:leafBoxes] = _leafBoxes_
      instance[:leafCenters] = _leafCenters_
      instance[:binIndices] = _binIndices_
      instance[:rebuildCapacity] = _rebuildCapacity_
      instance
    end
  end

  class TreeStats < FFI::Struct
    layout(
      :nodeVisits, :int,
      :leafVisits, :int,
    )
    def nodeVisits = self[:nodeVisits]
    def nodeVisits=(v) self[:nodeVisits] = v end
    def leafVisits = self[:leafVisits]
    def leafVisits=(v) self[:leafVisits] = v end
    def self.create_as(_nodeVisits_, _leafVisits_)
      instance = TreeStats.new
      instance[:nodeVisits] = _nodeVisits_
      instance[:leafVisits] = _leafVisits_
      instance
    end
  end


  # Function

  def self.setup_collision_symbols(method_naming: :original)
    entries = [
      [:IsValidRay, :b2IsValidRay, [:pointer], :bool],
      [:MakePolygon, :b2MakePolygon, [:pointer, :float], Polygon.by_value],
      [:MakeOffsetPolygon, :b2MakeOffsetPolygon, [:pointer, Vec2.by_value, Rot.by_value], Polygon.by_value],
      [:MakeOffsetRoundedPolygon, :b2MakeOffsetRoundedPolygon, [:pointer, Vec2.by_value, Rot.by_value, :float], Polygon.by_value],
      [:MakeSquare, :b2MakeSquare, [:float], Polygon.by_value],
      [:MakeBox, :b2MakeBox, [:float, :float], Polygon.by_value],
      [:MakeRoundedBox, :b2MakeRoundedBox, [:float, :float, :float], Polygon.by_value],
      [:MakeOffsetBox, :b2MakeOffsetBox, [:float, :float, Vec2.by_value, Rot.by_value], Polygon.by_value],
      [:MakeOffsetRoundedBox, :b2MakeOffsetRoundedBox, [:float, :float, Vec2.by_value, Rot.by_value, :float], Polygon.by_value],
      [:TransformPolygon, :b2TransformPolygon, [Transform.by_value, :pointer], Polygon.by_value],
      [:ComputeCircleMass, :b2ComputeCircleMass, [:pointer, :float], MassData.by_value],
      [:ComputeCapsuleMass, :b2ComputeCapsuleMass, [:pointer, :float], MassData.by_value],
      [:ComputePolygonMass, :b2ComputePolygonMass, [:pointer, :float], MassData.by_value],
      [:ComputeCircleAABB, :b2ComputeCircleAABB, [:pointer, Transform.by_value], AABB.by_value],
      [:ComputeCapsuleAABB, :b2ComputeCapsuleAABB, [:pointer, Transform.by_value], AABB.by_value],
      [:ComputePolygonAABB, :b2ComputePolygonAABB, [:pointer, Transform.by_value], AABB.by_value],
      [:ComputeSegmentAABB, :b2ComputeSegmentAABB, [:pointer, Transform.by_value], AABB.by_value],
      [:PointInCircle, :b2PointInCircle, [Vec2.by_value, :pointer], :bool],
      [:PointInCapsule, :b2PointInCapsule, [Vec2.by_value, :pointer], :bool],
      [:PointInPolygon, :b2PointInPolygon, [Vec2.by_value, :pointer], :bool],
      [:RayCastCircle, :b2RayCastCircle, [:pointer, :pointer], CastOutput.by_value],
      [:RayCastCapsule, :b2RayCastCapsule, [:pointer, :pointer], CastOutput.by_value],
      [:RayCastSegment, :b2RayCastSegment, [:pointer, :pointer, :bool], CastOutput.by_value],
      [:RayCastPolygon, :b2RayCastPolygon, [:pointer, :pointer], CastOutput.by_value],
      [:ShapeCastCircle, :b2ShapeCastCircle, [:pointer, :pointer], CastOutput.by_value],
      [:ShapeCastCapsule, :b2ShapeCastCapsule, [:pointer, :pointer], CastOutput.by_value],
      [:ShapeCastSegment, :b2ShapeCastSegment, [:pointer, :pointer], CastOutput.by_value],
      [:ShapeCastPolygon, :b2ShapeCastPolygon, [:pointer, :pointer], CastOutput.by_value],
      [:ComputeHull, :b2ComputeHull, [:pointer, :int], Hull.by_value],
      [:ValidateHull, :b2ValidateHull, [:pointer], :bool],
      [:SegmentDistance, :b2SegmentDistance, [Vec2.by_value, Vec2.by_value, Vec2.by_value, Vec2.by_value], SegmentDistanceResult.by_value],
      [:ShapeDistance, :b2ShapeDistance, [:pointer, :pointer, :pointer, :int], DistanceOutput.by_value],
      [:ShapeCast, :b2ShapeCast, [:pointer], CastOutput.by_value],
      [:MakeProxy, :b2MakeProxy, [:pointer, :int, :float], ShapeProxy.by_value],
      [:GetSweepTransform, :b2GetSweepTransform, [:pointer, :float], Transform.by_value],
      [:TimeOfImpact, :b2TimeOfImpact, [:pointer], TOIOutput.by_value],
      [:CollideCircles, :b2CollideCircles, [:pointer, Transform.by_value, :pointer, Transform.by_value], Manifold.by_value],
      [:CollideCapsuleAndCircle, :b2CollideCapsuleAndCircle, [:pointer, Transform.by_value, :pointer, Transform.by_value], Manifold.by_value],
      [:CollideSegmentAndCircle, :b2CollideSegmentAndCircle, [:pointer, Transform.by_value, :pointer, Transform.by_value], Manifold.by_value],
      [:CollidePolygonAndCircle, :b2CollidePolygonAndCircle, [:pointer, Transform.by_value, :pointer, Transform.by_value], Manifold.by_value],
      [:CollideCapsules, :b2CollideCapsules, [:pointer, Transform.by_value, :pointer, Transform.by_value], Manifold.by_value],
      [:CollideSegmentAndCapsule, :b2CollideSegmentAndCapsule, [:pointer, Transform.by_value, :pointer, Transform.by_value], Manifold.by_value],
      [:CollidePolygonAndCapsule, :b2CollidePolygonAndCapsule, [:pointer, Transform.by_value, :pointer, Transform.by_value], Manifold.by_value],
      [:CollidePolygons, :b2CollidePolygons, [:pointer, Transform.by_value, :pointer, Transform.by_value], Manifold.by_value],
      [:CollideSegmentAndPolygon, :b2CollideSegmentAndPolygon, [:pointer, Transform.by_value, :pointer, Transform.by_value], Manifold.by_value],
      [:CollideChainSegmentAndCircle, :b2CollideChainSegmentAndCircle, [:pointer, Transform.by_value, :pointer, Transform.by_value], Manifold.by_value],
      [:CollideChainSegmentAndCapsule, :b2CollideChainSegmentAndCapsule, [:pointer, Transform.by_value, :pointer, Transform.by_value, :pointer], Manifold.by_value],
      [:CollideChainSegmentAndPolygon, :b2CollideChainSegmentAndPolygon, [:pointer, Transform.by_value, :pointer, Transform.by_value, :pointer], Manifold.by_value],
      [:DynamicTree_Create, :b2DynamicTree_Create, [], DynamicTree.by_value],
      [:DynamicTree_Destroy, :b2DynamicTree_Destroy, [:pointer], :void],
      [:DynamicTree_CreateProxy, :b2DynamicTree_CreateProxy, [:pointer, AABB.by_value, :ulong_long, :int], :int],
      [:DynamicTree_DestroyProxy, :b2DynamicTree_DestroyProxy, [:pointer, :int], :void],
      [:DynamicTree_MoveProxy, :b2DynamicTree_MoveProxy, [:pointer, :int, AABB.by_value], :void],
      [:DynamicTree_EnlargeProxy, :b2DynamicTree_EnlargeProxy, [:pointer, :int, AABB.by_value], :void],
      [:DynamicTree_Query, :b2DynamicTree_Query, [:pointer, AABB.by_value, :ulong_long, :pointer, :pointer], TreeStats.by_value],
      [:DynamicTree_RayCast, :b2DynamicTree_RayCast, [:pointer, :pointer, :ulong_long, :pointer, :pointer], TreeStats.by_value],
      [:DynamicTree_ShapeCast, :b2DynamicTree_ShapeCast, [:pointer, :pointer, :ulong_long, :pointer, :pointer], TreeStats.by_value],
      [:DynamicTree_Validate, :b2DynamicTree_Validate, [:pointer], :void],
      [:DynamicTree_GetHeight, :b2DynamicTree_GetHeight, [:pointer], :int],
      [:DynamicTree_GetAreaRatio, :b2DynamicTree_GetAreaRatio, [:pointer], :float],
      [:DynamicTree_GetProxyCount, :b2DynamicTree_GetProxyCount, [:pointer], :int],
      [:DynamicTree_Rebuild, :b2DynamicTree_Rebuild, [:pointer, :bool], :int],
      [:DynamicTree_GetByteCount, :b2DynamicTree_GetByteCount, [:pointer], :int],
    ]
    entries.each do |entry|
      api_name = if method_naming == :snake_case
                   snake_case_name = entry[0].to_s.gsub(/([A-Z]+)([A-Z0-9][a-z])/, '\1_\2').gsub(/([a-z\d])([A-Z0-9])/, '\1_\2').downcase
                   snake_case_name.gsub!('vector_3', 'vector3_') if snake_case_name.include?('vector_3')
                   snake_case_name.gsub!('vector_2', 'vector2_') if snake_case_name.include?('vector_2')
                   snake_case_name.chop! if snake_case_name.end_with?('_')
                   snake_case_name.to_sym
                 else
                   entry[0]
                 end
      attach_function api_name, entry[1], entry[2], entry[3]
    rescue FFI::NotFoundError => e
      warn "[Warning] Failed to import #{entry[0]} (#{e})."
    end
  end

end

