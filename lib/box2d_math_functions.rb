# Ruby-Box2D : Yet another Box2D wrapper for Ruby
#
# * https://github.com/vaiorabbit/box2d-bindings
#
# [NOTICE] Autogenerated. Do not edit.

require 'ffi'

module Box2D
  extend FFI::Library
  # Define/Macro


  # Enum


  # Typedef


  # Struct

  class Vec2 < FFI::Struct
    layout(
      :x, :float,
      :y, :float,
    )
    def x = self[:x]
    def x=(v) self[:x] = v end
    def y = self[:y]
    def y=(v) self[:y] = v end
    def self.create_as(_x_, _y_)
      instance = Vec2.new
      instance[:x] = _x_
      instance[:y] = _y_
      instance
    end
  end

  class CosSin < FFI::Struct
    layout(
      :cosine, :float,
      :sine, :float,
    )
    def cosine = self[:cosine]
    def cosine=(v) self[:cosine] = v end
    def sine = self[:sine]
    def sine=(v) self[:sine] = v end
    def self.create_as(_cosine_, _sine_)
      instance = CosSin.new
      instance[:cosine] = _cosine_
      instance[:sine] = _sine_
      instance
    end
  end

  class Rot < FFI::Struct
    layout(
      :c, :float,
      :s, :float,
    )
    def c = self[:c]
    def c=(v) self[:c] = v end
    def s = self[:s]
    def s=(v) self[:s] = v end
    def self.create_as(_c_, _s_)
      instance = Rot.new
      instance[:c] = _c_
      instance[:s] = _s_
      instance
    end
  end

  class Transform < FFI::Struct
    layout(
      :p, Vec2,
      :q, Rot,
    )
    def p = self[:p]
    def p=(v) self[:p] = v end
    def q = self[:q]
    def q=(v) self[:q] = v end
    def self.create_as(_p_, _q_)
      instance = Transform.new
      instance[:p] = _p_
      instance[:q] = _q_
      instance
    end
  end

  class Mat22 < FFI::Struct
    layout(
      :cx, Vec2,
      :cy, Vec2,
    )
    def cx = self[:cx]
    def cx=(v) self[:cx] = v end
    def cy = self[:cy]
    def cy=(v) self[:cy] = v end
    def self.create_as(_cx_, _cy_)
      instance = Mat22.new
      instance[:cx] = _cx_
      instance[:cy] = _cy_
      instance
    end
  end

  class AABB < FFI::Struct
    layout(
      :lowerBound, Vec2,
      :upperBound, Vec2,
    )
    def lowerBound = self[:lowerBound]
    def lowerBound=(v) self[:lowerBound] = v end
    def upperBound = self[:upperBound]
    def upperBound=(v) self[:upperBound] = v end
    def self.create_as(_lowerBound_, _upperBound_)
      instance = AABB.new
      instance[:lowerBound] = _lowerBound_
      instance[:upperBound] = _upperBound_
      instance
    end
  end


  # Function

  def self.setup_math_functions_symbols(output_error = false)
    symbols = [
      :b2Atan2,
      :b2ComputeCosSin,
      :b2IsValid,
      :b2Vec2_IsValid,
      :b2Rot_IsValid,
      :b2AABB_IsValid,
      :b2SetLengthUnitsPerMeter,
      :b2GetLengthUnitsPerMeter,
    ]
    apis = {
      :b2Atan2 => :Atan2,
      :b2ComputeCosSin => :ComputeCosSin,
      :b2IsValid => :IsValid,
      :b2Vec2_IsValid => :Vec2_IsValid,
      :b2Rot_IsValid => :Rot_IsValid,
      :b2AABB_IsValid => :AABB_IsValid,
      :b2SetLengthUnitsPerMeter => :SetLengthUnitsPerMeter,
      :b2GetLengthUnitsPerMeter => :GetLengthUnitsPerMeter,
    }
    args = {
      :b2Atan2 => [:float, :float],
      :b2ComputeCosSin => [:float],
      :b2IsValid => [:float],
      :b2Vec2_IsValid => [Vec2.by_value],
      :b2Rot_IsValid => [Rot.by_value],
      :b2AABB_IsValid => [AABB.by_value],
      :b2SetLengthUnitsPerMeter => [:float],
      :b2GetLengthUnitsPerMeter => [],
    }
    retvals = {
      :b2Atan2 => :float,
      :b2ComputeCosSin => CosSin.by_value,
      :b2IsValid => :bool,
      :b2Vec2_IsValid => :bool,
      :b2Rot_IsValid => :bool,
      :b2AABB_IsValid => :bool,
      :b2SetLengthUnitsPerMeter => :void,
      :b2GetLengthUnitsPerMeter => :float,
    }
    symbols.each do |sym|
      begin
        attach_function apis[sym], sym, args[sym], retvals[sym]
      rescue FFI::NotFoundError => error
        $stderr.puts("[Warning] Failed to import #{sym} (#{error}).") if output_error
      end
    end
  end

end

