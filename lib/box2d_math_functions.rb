# Ruby-Box2D : Yet another Box2D wrapper for Ruby
#
# * https://github.com/vaiorabbit/box2d-bindings
#
# [NOTICE] Autogenerated. Do not edit.

require 'ffi'

module Box2D
  extend FFI::Library
  # Define/Macro


  # Enum


  # Typedef


  # Struct

  class Vec2 < FFI::Struct
    layout(
      :x, :float,
      :y, :float,
    )
    def x = self[:x]
    def x=(v) self[:x] = v end
    def y = self[:y]
    def y=(v) self[:y] = v end
    def self.create_as(_x_, _y_)
      instance = Vec2.new
      instance[:x] = _x_
      instance[:y] = _y_
      instance
    end
  end

  class CosSin < FFI::Struct
    layout(
      :cosine, :float,
      :sine, :float,
    )
    def cosine = self[:cosine]
    def cosine=(v) self[:cosine] = v end
    def sine = self[:sine]
    def sine=(v) self[:sine] = v end
    def self.create_as(_cosine_, _sine_)
      instance = CosSin.new
      instance[:cosine] = _cosine_
      instance[:sine] = _sine_
      instance
    end
  end

  class Rot < FFI::Struct
    layout(
      :c, :float,
      :s, :float,
    )
    def c = self[:c]
    def c=(v) self[:c] = v end
    def s = self[:s]
    def s=(v) self[:s] = v end
    def self.create_as(_c_, _s_)
      instance = Rot.new
      instance[:c] = _c_
      instance[:s] = _s_
      instance
    end
  end

  class Transform < FFI::Struct
    layout(
      :p, Vec2,
      :q, Rot,
    )
    def p = self[:p]
    def p=(v) self[:p] = v end
    def q = self[:q]
    def q=(v) self[:q] = v end
    def self.create_as(_p_, _q_)
      instance = Transform.new
      instance[:p] = _p_
      instance[:q] = _q_
      instance
    end
  end

  class Mat22 < FFI::Struct
    layout(
      :cx, Vec2,
      :cy, Vec2,
    )
    def cx = self[:cx]
    def cx=(v) self[:cx] = v end
    def cy = self[:cy]
    def cy=(v) self[:cy] = v end
    def self.create_as(_cx_, _cy_)
      instance = Mat22.new
      instance[:cx] = _cx_
      instance[:cy] = _cy_
      instance
    end
  end

  class AABB < FFI::Struct
    layout(
      :lowerBound, Vec2,
      :upperBound, Vec2,
    )
    def lowerBound = self[:lowerBound]
    def lowerBound=(v) self[:lowerBound] = v end
    def upperBound = self[:upperBound]
    def upperBound=(v) self[:upperBound] = v end
    def self.create_as(_lowerBound_, _upperBound_)
      instance = AABB.new
      instance[:lowerBound] = _lowerBound_
      instance[:upperBound] = _upperBound_
      instance
    end
  end


  # Function

  def self.setup_math_functions_symbols(method_naming: :original)
    entries = [
      [:Atan2, :b2Atan2, [:float, :float], :float],
      [:ComputeCosSin, :b2ComputeCosSin, [:float], CosSin.by_value],
      [:ComputeRotationBetweenUnitVectors, :b2ComputeRotationBetweenUnitVectors, [Vec2.by_value, Vec2.by_value], Rot.by_value],
      [:IsValidFloat, :b2IsValidFloat, [:float], :bool],
      [:IsValidVec2, :b2IsValidVec2, [Vec2.by_value], :bool],
      [:IsValidRotation, :b2IsValidRotation, [Rot.by_value], :bool],
      [:IsValidAABB, :b2IsValidAABB, [AABB.by_value], :bool],
      [:SetLengthUnitsPerMeter, :b2SetLengthUnitsPerMeter, [:float], :void],
      [:GetLengthUnitsPerMeter, :b2GetLengthUnitsPerMeter, [], :float],
    ]
    entries.each do |entry|
      api_name = if method_naming == :snake_case
                   snake_case_name = entry[0].to_s.gsub(/([A-Z]+)([A-Z0-9][a-z])/, '\1_\2').gsub(/([a-z\d])([A-Z0-9])/, '\1_\2').downcase
                   snake_case_name.gsub!('vector_3', 'vector3_') if snake_case_name.include?('vector_3')
                   snake_case_name.gsub!('vector_2', 'vector2_') if snake_case_name.include?('vector_2')
                   snake_case_name.chop! if snake_case_name.end_with?('_')
                   snake_case_name.to_sym
                 else
                   entry[0]
                 end
      attach_function api_name, entry[1], entry[2], entry[3]
    rescue FFI::NotFoundError => e
      warn "[Warning] Failed to import #{entry[0]} (#{e})."
    end
  end

end

