# Ruby-Box2D : Yet another Box2D wrapper for Ruby
#
# * https://github.com/vaiorabbit/box2d-bindings
#
# [NOTICE] Autogenerated. Do not edit.

require 'ffi'

module Box2D
  extend FFI::Library
  # Define/Macro


  # Enum


  # Typedef


  # Struct


  # Function

  def self.setup_math_inline_functions_symbols(method_naming: :original)
    entries = [
      [:MinInt, :b2MinInt, [:int, :int], :int],
      [:MaxInt, :b2MaxInt, [:int, :int], :int],
      [:AbsInt, :b2AbsInt, [:int], :int],
      [:ClampInt, :b2ClampInt, [:int, :int, :int], :int],
      [:MinFloat, :b2MinFloat, [:float, :float], :float],
      [:MaxFloat, :b2MaxFloat, [:float, :float], :float],
      [:AbsFloat, :b2AbsFloat, [:float], :float],
      [:ClampFloat, :b2ClampFloat, [:float, :float, :float], :float],
      [:Dot, :b2Dot, [Vec2.by_value, Vec2.by_value], :float],
      [:Cross, :b2Cross, [Vec2.by_value, Vec2.by_value], :float],
      [:CrossVS, :b2CrossVS, [Vec2.by_value, :float], Vec2.by_value],
      [:CrossSV, :b2CrossSV, [:float, Vec2.by_value], Vec2.by_value],
      [:LeftPerp, :b2LeftPerp, [Vec2.by_value], Vec2.by_value],
      [:RightPerp, :b2RightPerp, [Vec2.by_value], Vec2.by_value],
      [:Add, :b2Add, [Vec2.by_value, Vec2.by_value], Vec2.by_value],
      [:Sub, :b2Sub, [Vec2.by_value, Vec2.by_value], Vec2.by_value],
      [:Neg, :b2Neg, [Vec2.by_value], Vec2.by_value],
      [:Lerp, :b2Lerp, [Vec2.by_value, Vec2.by_value, :float], Vec2.by_value],
      [:Mul, :b2Mul, [Vec2.by_value, Vec2.by_value], Vec2.by_value],
      [:MulSV, :b2MulSV, [:float, Vec2.by_value], Vec2.by_value],
      [:MulAdd, :b2MulAdd, [Vec2.by_value, :float, Vec2.by_value], Vec2.by_value],
      [:MulSub, :b2MulSub, [Vec2.by_value, :float, Vec2.by_value], Vec2.by_value],
      [:Abs, :b2Abs, [Vec2.by_value], Vec2.by_value],
      [:Min, :b2Min, [Vec2.by_value, Vec2.by_value], Vec2.by_value],
      [:Max, :b2Max, [Vec2.by_value, Vec2.by_value], Vec2.by_value],
      [:Clamp, :b2Clamp, [Vec2.by_value, Vec2.by_value, Vec2.by_value], Vec2.by_value],
      [:Length, :b2Length, [Vec2.by_value], :float],
      [:Distance, :b2Distance, [Vec2.by_value, Vec2.by_value], :float],
      [:Normalize, :b2Normalize, [Vec2.by_value], Vec2.by_value],
      [:GetLengthAndNormalize, :b2GetLengthAndNormalize, [:pointer, Vec2.by_value], Vec2.by_value],
      [:NormalizeRot, :b2NormalizeRot, [Rot.by_value], Rot.by_value],
      [:IntegrateRotation, :b2IntegrateRotation, [Rot.by_value, :float], Rot.by_value],
      [:LengthSquared, :b2LengthSquared, [Vec2.by_value], :float],
      [:DistanceSquared, :b2DistanceSquared, [Vec2.by_value, Vec2.by_value], :float],
      [:MakeRot, :b2MakeRot, [:float], Rot.by_value],
      [:IsNormalized, :b2IsNormalized, [Rot.by_value], :bool],
      [:NLerp, :b2NLerp, [Rot.by_value, Rot.by_value, :float], Rot.by_value],
      [:ComputeAngularVelocity, :b2ComputeAngularVelocity, [Rot.by_value, Rot.by_value, :float], :float],
      [:Rot_GetAngle, :b2Rot_GetAngle, [Rot.by_value], :float],
      [:Rot_GetXAxis, :b2Rot_GetXAxis, [Rot.by_value], Vec2.by_value],
      [:Rot_GetYAxis, :b2Rot_GetYAxis, [Rot.by_value], Vec2.by_value],
      [:MulRot, :b2MulRot, [Rot.by_value, Rot.by_value], Rot.by_value],
      [:InvMulRot, :b2InvMulRot, [Rot.by_value, Rot.by_value], Rot.by_value],
      [:RelativeAngle, :b2RelativeAngle, [Rot.by_value, Rot.by_value], :float],
      [:UnwindAngle, :b2UnwindAngle, [:float], :float],
      [:UnwindLargeAngle, :b2UnwindLargeAngle, [:float], :float],
      [:RotateVector, :b2RotateVector, [Rot.by_value, Vec2.by_value], Vec2.by_value],
      [:InvRotateVector, :b2InvRotateVector, [Rot.by_value, Vec2.by_value], Vec2.by_value],
      [:TransformPoint, :b2TransformPoint, [Transform.by_value, Vec2.by_value], Vec2.by_value],
      [:InvTransformPoint, :b2InvTransformPoint, [Transform.by_value, Vec2.by_value], Vec2.by_value],
      [:MulTransforms, :b2MulTransforms, [Transform.by_value, Transform.by_value], Transform.by_value],
      [:InvMulTransforms, :b2InvMulTransforms, [Transform.by_value, Transform.by_value], Transform.by_value],
      [:MulMV, :b2MulMV, [Mat22.by_value, Vec2.by_value], Vec2.by_value],
      [:GetInverse22, :b2GetInverse22, [Mat22.by_value], Mat22.by_value],
      [:Solve22, :b2Solve22, [Mat22.by_value, Vec2.by_value], Vec2.by_value],
      [:AABB_Contains, :b2AABB_Contains, [AABB.by_value, AABB.by_value], :bool],
      [:AABB_Center, :b2AABB_Center, [AABB.by_value], Vec2.by_value],
      [:AABB_Extents, :b2AABB_Extents, [AABB.by_value], Vec2.by_value],
      [:AABB_Union, :b2AABB_Union, [AABB.by_value, AABB.by_value], AABB.by_value],
    ]
    entries.each do |entry|
      api_name = if method_naming == :snake_case
                   snake_case_name = entry[0].to_s.gsub(/([A-Z]+)([A-Z0-9][a-z])/, '\1_\2').gsub(/([a-z\d])([A-Z0-9])/, '\1_\2').downcase
                   snake_case_name.gsub!('vector_3', 'vector3_') if snake_case_name.include?('vector_3')
                   snake_case_name.gsub!('vector_2', 'vector2_') if snake_case_name.include?('vector_2')
                   snake_case_name.chop! if snake_case_name.end_with?('_')
                   snake_case_name.to_sym
                 else
                   entry[0]
                 end
      attach_function api_name, entry[1], entry[2], entry[3]
    rescue FFI::NotFoundError => e
      warn "[Warning] Failed to import #{entry[0]} (#{e})."
    end
  end

end

