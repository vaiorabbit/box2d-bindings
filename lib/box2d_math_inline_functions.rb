# Ruby-Box2D : Yet another Box2D wrapper for Ruby
#
# * https://github.com/vaiorabbit/box2d-bindings
#
# [NOTICE] Autogenerated. Do not edit.

require 'ffi'

module Box2D
  extend FFI::Library
  # Define/Macro


  # Enum


  # Typedef


  # Struct


  # Function

  def self.setup_math_inline_functions_symbols(output_error = false)
    symbols = [
      :b2MinInt,
      :b2MaxInt,
      :b2AbsInt,
      :b2ClampInt,
      :b2MinFloat,
      :b2MaxFloat,
      :b2AbsFloat,
      :b2ClampFloat,
      :b2Dot,
      :b2Cross,
      :b2CrossVS,
      :b2CrossSV,
      :b2LeftPerp,
      :b2RightPerp,
      :b2Add,
      :b2Sub,
      :b2Neg,
      :b2Lerp,
      :b2Mul,
      :b2MulSV,
      :b2MulAdd,
      :b2MulSub,
      :b2Abs,
      :b2Min,
      :b2Max,
      :b2Clamp,
      :b2Length,
      :b2Distance,
      :b2Normalize,
      :b2GetLengthAndNormalize,
      :b2NormalizeRot,
      :b2IntegrateRotation,
      :b2LengthSquared,
      :b2DistanceSquared,
      :b2MakeRot,
      :b2IsNormalized,
      :b2NLerp,
      :b2ComputeAngularVelocity,
      :b2Rot_GetAngle,
      :b2Rot_GetXAxis,
      :b2Rot_GetYAxis,
      :b2MulRot,
      :b2InvMulRot,
      :b2RelativeAngle,
      :b2UnwindAngle,
      :b2UnwindLargeAngle,
      :b2RotateVector,
      :b2InvRotateVector,
      :b2TransformPoint,
      :b2InvTransformPoint,
      :b2MulTransforms,
      :b2InvMulTransforms,
      :b2MulMV,
      :b2GetInverse22,
      :b2Solve22,
      :b2AABB_Contains,
      :b2AABB_Center,
      :b2AABB_Extents,
      :b2AABB_Union,
    ]
    apis = {
      :b2MinInt => :MinInt,
      :b2MaxInt => :MaxInt,
      :b2AbsInt => :AbsInt,
      :b2ClampInt => :ClampInt,
      :b2MinFloat => :MinFloat,
      :b2MaxFloat => :MaxFloat,
      :b2AbsFloat => :AbsFloat,
      :b2ClampFloat => :ClampFloat,
      :b2Dot => :Dot,
      :b2Cross => :Cross,
      :b2CrossVS => :CrossVS,
      :b2CrossSV => :CrossSV,
      :b2LeftPerp => :LeftPerp,
      :b2RightPerp => :RightPerp,
      :b2Add => :Add,
      :b2Sub => :Sub,
      :b2Neg => :Neg,
      :b2Lerp => :Lerp,
      :b2Mul => :Mul,
      :b2MulSV => :MulSV,
      :b2MulAdd => :MulAdd,
      :b2MulSub => :MulSub,
      :b2Abs => :Abs,
      :b2Min => :Min,
      :b2Max => :Max,
      :b2Clamp => :Clamp,
      :b2Length => :Length,
      :b2Distance => :Distance,
      :b2Normalize => :Normalize,
      :b2GetLengthAndNormalize => :GetLengthAndNormalize,
      :b2NormalizeRot => :NormalizeRot,
      :b2IntegrateRotation => :IntegrateRotation,
      :b2LengthSquared => :LengthSquared,
      :b2DistanceSquared => :DistanceSquared,
      :b2MakeRot => :MakeRot,
      :b2IsNormalized => :IsNormalized,
      :b2NLerp => :NLerp,
      :b2ComputeAngularVelocity => :ComputeAngularVelocity,
      :b2Rot_GetAngle => :Rot_GetAngle,
      :b2Rot_GetXAxis => :Rot_GetXAxis,
      :b2Rot_GetYAxis => :Rot_GetYAxis,
      :b2MulRot => :MulRot,
      :b2InvMulRot => :InvMulRot,
      :b2RelativeAngle => :RelativeAngle,
      :b2UnwindAngle => :UnwindAngle,
      :b2UnwindLargeAngle => :UnwindLargeAngle,
      :b2RotateVector => :RotateVector,
      :b2InvRotateVector => :InvRotateVector,
      :b2TransformPoint => :TransformPoint,
      :b2InvTransformPoint => :InvTransformPoint,
      :b2MulTransforms => :MulTransforms,
      :b2InvMulTransforms => :InvMulTransforms,
      :b2MulMV => :MulMV,
      :b2GetInverse22 => :GetInverse22,
      :b2Solve22 => :Solve22,
      :b2AABB_Contains => :AABB_Contains,
      :b2AABB_Center => :AABB_Center,
      :b2AABB_Extents => :AABB_Extents,
      :b2AABB_Union => :AABB_Union,
    }
    args = {
      :b2MinInt => [:int, :int],
      :b2MaxInt => [:int, :int],
      :b2AbsInt => [:int],
      :b2ClampInt => [:int, :int, :int],
      :b2MinFloat => [:float, :float],
      :b2MaxFloat => [:float, :float],
      :b2AbsFloat => [:float],
      :b2ClampFloat => [:float, :float, :float],
      :b2Dot => [Vec2.by_value, Vec2.by_value],
      :b2Cross => [Vec2.by_value, Vec2.by_value],
      :b2CrossVS => [Vec2.by_value, :float],
      :b2CrossSV => [:float, Vec2.by_value],
      :b2LeftPerp => [Vec2.by_value],
      :b2RightPerp => [Vec2.by_value],
      :b2Add => [Vec2.by_value, Vec2.by_value],
      :b2Sub => [Vec2.by_value, Vec2.by_value],
      :b2Neg => [Vec2.by_value],
      :b2Lerp => [Vec2.by_value, Vec2.by_value, :float],
      :b2Mul => [Vec2.by_value, Vec2.by_value],
      :b2MulSV => [:float, Vec2.by_value],
      :b2MulAdd => [Vec2.by_value, :float, Vec2.by_value],
      :b2MulSub => [Vec2.by_value, :float, Vec2.by_value],
      :b2Abs => [Vec2.by_value],
      :b2Min => [Vec2.by_value, Vec2.by_value],
      :b2Max => [Vec2.by_value, Vec2.by_value],
      :b2Clamp => [Vec2.by_value, Vec2.by_value, Vec2.by_value],
      :b2Length => [Vec2.by_value],
      :b2Distance => [Vec2.by_value, Vec2.by_value],
      :b2Normalize => [Vec2.by_value],
      :b2GetLengthAndNormalize => [:pointer, Vec2.by_value],
      :b2NormalizeRot => [Rot.by_value],
      :b2IntegrateRotation => [Rot.by_value, :float],
      :b2LengthSquared => [Vec2.by_value],
      :b2DistanceSquared => [Vec2.by_value, Vec2.by_value],
      :b2MakeRot => [:float],
      :b2IsNormalized => [Rot.by_value],
      :b2NLerp => [Rot.by_value, Rot.by_value, :float],
      :b2ComputeAngularVelocity => [Rot.by_value, Rot.by_value, :float],
      :b2Rot_GetAngle => [Rot.by_value],
      :b2Rot_GetXAxis => [Rot.by_value],
      :b2Rot_GetYAxis => [Rot.by_value],
      :b2MulRot => [Rot.by_value, Rot.by_value],
      :b2InvMulRot => [Rot.by_value, Rot.by_value],
      :b2RelativeAngle => [Rot.by_value, Rot.by_value],
      :b2UnwindAngle => [:float],
      :b2UnwindLargeAngle => [:float],
      :b2RotateVector => [Rot.by_value, Vec2.by_value],
      :b2InvRotateVector => [Rot.by_value, Vec2.by_value],
      :b2TransformPoint => [Transform.by_value, Vec2.by_value],
      :b2InvTransformPoint => [Transform.by_value, Vec2.by_value],
      :b2MulTransforms => [Transform.by_value, Transform.by_value],
      :b2InvMulTransforms => [Transform.by_value, Transform.by_value],
      :b2MulMV => [Mat22.by_value, Vec2.by_value],
      :b2GetInverse22 => [Mat22.by_value],
      :b2Solve22 => [Mat22.by_value, Vec2.by_value],
      :b2AABB_Contains => [AABB.by_value, AABB.by_value],
      :b2AABB_Center => [AABB.by_value],
      :b2AABB_Extents => [AABB.by_value],
      :b2AABB_Union => [AABB.by_value, AABB.by_value],
    }
    retvals = {
      :b2MinInt => :int,
      :b2MaxInt => :int,
      :b2AbsInt => :int,
      :b2ClampInt => :int,
      :b2MinFloat => :float,
      :b2MaxFloat => :float,
      :b2AbsFloat => :float,
      :b2ClampFloat => :float,
      :b2Dot => :float,
      :b2Cross => :float,
      :b2CrossVS => Vec2.by_value,
      :b2CrossSV => Vec2.by_value,
      :b2LeftPerp => Vec2.by_value,
      :b2RightPerp => Vec2.by_value,
      :b2Add => Vec2.by_value,
      :b2Sub => Vec2.by_value,
      :b2Neg => Vec2.by_value,
      :b2Lerp => Vec2.by_value,
      :b2Mul => Vec2.by_value,
      :b2MulSV => Vec2.by_value,
      :b2MulAdd => Vec2.by_value,
      :b2MulSub => Vec2.by_value,
      :b2Abs => Vec2.by_value,
      :b2Min => Vec2.by_value,
      :b2Max => Vec2.by_value,
      :b2Clamp => Vec2.by_value,
      :b2Length => :float,
      :b2Distance => :float,
      :b2Normalize => Vec2.by_value,
      :b2GetLengthAndNormalize => Vec2.by_value,
      :b2NormalizeRot => Rot.by_value,
      :b2IntegrateRotation => Rot.by_value,
      :b2LengthSquared => :float,
      :b2DistanceSquared => :float,
      :b2MakeRot => Rot.by_value,
      :b2IsNormalized => :bool,
      :b2NLerp => Rot.by_value,
      :b2ComputeAngularVelocity => :float,
      :b2Rot_GetAngle => :float,
      :b2Rot_GetXAxis => Vec2.by_value,
      :b2Rot_GetYAxis => Vec2.by_value,
      :b2MulRot => Rot.by_value,
      :b2InvMulRot => Rot.by_value,
      :b2RelativeAngle => :float,
      :b2UnwindAngle => :float,
      :b2UnwindLargeAngle => :float,
      :b2RotateVector => Vec2.by_value,
      :b2InvRotateVector => Vec2.by_value,
      :b2TransformPoint => Vec2.by_value,
      :b2InvTransformPoint => Vec2.by_value,
      :b2MulTransforms => Transform.by_value,
      :b2InvMulTransforms => Transform.by_value,
      :b2MulMV => Vec2.by_value,
      :b2GetInverse22 => Mat22.by_value,
      :b2Solve22 => Vec2.by_value,
      :b2AABB_Contains => :bool,
      :b2AABB_Center => Vec2.by_value,
      :b2AABB_Extents => Vec2.by_value,
      :b2AABB_Union => AABB.by_value,
    }
    symbols.each do |sym|
      begin
        attach_function apis[sym], sym, args[sym], retvals[sym]
      rescue FFI::NotFoundError => error
        $stderr.puts("[Warning] Failed to import #{sym} (#{error}).") if output_error
      end
    end
  end

end

